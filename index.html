<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Viral Studio 16.0 - Pro Motion Graphics Suite</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- FONTS -->
    <link
        href="https://fonts.googleapis.com/css2?family=Montserrat:wght@900&family=Noto+Sans+Kannada:wght@700;900&family=Noto+Serif+Kannada:wght@700;900&family=Baloo+Tamma+2:wght@600;800&family=Hubballi&family=Tiro+Kannada:ital@0;1&family=Anek+Kannada:wght@600;800&family=Poppins:wght@700;900&family=Permanent+Marker&display=swap"
        rel="stylesheet">
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        body {
            font-family: 'Poppins', 'Segoe UI Emoji', sans-serif;
            background-color: #050505;
            color: #fff;
            overflow: hidden;
        }

        ::-webkit-scrollbar {
            width: 6px;
        }

        ::-webkit-scrollbar-track {
            background: #111;
        }

        ::-webkit-scrollbar-thumb {
            background: #444;
            border-radius: 10px;
        }

        input[type="file"] {
            display: none;
        }

        .active-format {
            border-color: #a855f7;
            color: white;
            background: rgba(168, 85, 247, 0.1);
        }

        .transition-all-smooth {
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .color-wrapper {
            position: relative;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.2);
            overflow: hidden;
            cursor: pointer;
        }

        .color-wrapper input {
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            opacity: 0;
            cursor: pointer;
        }

        .asset-chip {
            display: flex;
            align-items: center;
            gap: 5px;
            background: #222;
            padding: 2px 8px;
            border-radius: 12px;
            border: 1px solid #333;
            font-size: 10px;
        }

        .asset-chip img {
            width: 16px;
            height: 16px;
            object-fit: cover;
            border-radius: 4px;
        }

        .asset-chip video {
            width: 16px;
            height: 16px;
            object-fit: cover;
            border-radius: 4px;
        }

        .scanlines {
            background: linear-gradient(to bottom, rgba(255, 255, 255, 0), rgba(255, 255, 255, 0) 50%, rgba(0, 0, 0, 0.2) 50%, rgba(0, 0, 0, 0.2));
            background-size: 100% 4px;
            pointer-events: none;
        }

        .noise-overlay {
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.65' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)' opacity='0.1'/%3E%3C/svg%3E");
            opacity: 0.15;
            pointer-events: none;
        }

        @keyframes pulse-red {
            0% {
                box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7);
            }

            70% {
                box-shadow: 0 0 0 6px rgba(239, 68, 68, 0);
            }

            100% {
                box-shadow: 0 0 0 0 rgba(239, 68, 68, 0);
            }
        }

        .recording-pulse {
            animation: pulse-red 1.5s infinite;
            border-color: #ef4444 !important;
        }

        .tab-active {
            color: #a855f7;
            border-bottom: 2px solid #a855f7;
        }

        .tab-inactive {
            color: #6b7280;
            border-bottom: 2px solid transparent;
        }

        .sub-tab-active {
            background: rgba(168, 85, 247, 0.2);
            color: #e9d5ff;
            border: 1px solid #a855f7;
        }

        .sub-tab-inactive {
            background: rgba(255, 255, 255, 0.05);
            color: #9ca3af;
            border: 1px solid transparent;
        }

        /* Compact Scene Card Styles */
        .scene-card {
            background: #151517;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 8px;
            margin-bottom: 6px;
            position: relative;
            transition: all 0.2s;
        }

        .scene-card:hover {
            border-color: rgba(168, 85, 247, 0.4);
        }

        .scene-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 4px;
        }

        .scene-label {
            font-size: 9px;
            color: #a855f7;
            font-weight: bold;
            text-transform: uppercase;
        }

        .scene-controls {
            display: flex;
            gap: 4px;
            margin-bottom: 6px;
        }

        .scene-select {
            background: #000;
            border: 1px solid rgba(255, 255, 255, 0.15);
            color: #ddd;
            font-size: 9px;
            padding: 2px 4px;
            border-radius: 4px;
            flex: 1;
            outline: none;
            height: 24px;
        }

        .scene-btn {
            padding: 2px 6px;
            font-size: 9px;
            border-radius: 4px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            cursor: pointer;
            transition: background 0.2s;
        }

        .scene-btn.active {
            background: #a855f7;
            color: white;
            border-color: #a855f7;
        }

        .scene-btn:hover:not(.active) {
            background: rgba(255, 255, 255, 0.1);
        }

        .split-btn {
            color: #3b82f6;
            font-size: 9px;
            display: flex;
            align-items: center;
            gap: 2px;
            cursor: pointer;
        }

        .split-btn:hover {
            text-decoration: underline;
        }
    </style>
</head>

<body class="flex flex-col-reverse md:flex-row h-[100dvh] w-screen bg-[#050505] text-white overflow-hidden">

    <!-- SIDEBAR -->
    <div
        class="w-full md:w-[450px] flex flex-col border-t md:border-t-0 md:border-r border-white/10 bg-[#0f0f11] z-20 shadow-2xl h-[55%] md:h-full shrink-0">
        <div class="p-4 md:p-5 border-b border-white/10 bg-[#0f0f11] shrink-0">
            <h1 class="text-lg md:text-xl font-black italic tracking-tighter text-white font-[Montserrat]">
                VIRAL<span class="text-purple-500">STUDIO</span> 16.0
            </h1>

            <!-- MASTER APP TABS -->
            <div class="flex mt-3 bg-[#050505] p-1 rounded-xl border border-white/10 shadow-inner">
                <button onclick="setAppMode('classic')" id="tabClassic"
                    class="flex-1 py-2 text-[10px] font-bold rounded-lg transition-all bg-purple-600 text-white shadow-lg">1.
                    Classic (Word-by-Word)</button>
                <button onclick="setAppMode('pro')" id="tabPro"
                    class="flex-1 py-2 text-[10px] font-bold rounded-lg transition-all text-gray-500 hover:text-white">2.
                    Pro (Karaoke Motion) ‚ú®</button>
            </div>
        </div>

        <div class="flex-1 overflow-y-auto p-4 md:p-5 space-y-6 custom-scroll">

            <!-- 1. FORMAT & BACKGROUND -->
            <div class="space-y-3">
                <label class="text-[10px] font-bold text-gray-400 uppercase tracking-wider flex items-center gap-2">
                    <i data-lucide="layout" class="w-3 h-3"></i> 1. Format & Background
                </label>
                <div class="flex flex-wrap gap-2 mb-2">
                    <button onclick="setFormat('9:16')" id="fmt916"
                        class="flex-1 p-2 rounded-lg border border-white/10 text-[10px] font-bold text-gray-400 hover:bg-white/5 transition active-format">üì±
                        9:16</button>
                    <button onclick="setFormat('4:3')" id="fmt43"
                        class="flex-1 p-2 rounded-lg border border-white/10 text-[10px] font-bold text-gray-400 hover:bg-white/5 transition">üì∫
                        4:3</button>
                    <button onclick="setFormat('1:1')" id="fmt11"
                        class="flex-1 p-2 rounded-lg border border-white/10 text-[10px] font-bold text-gray-400 hover:bg-white/5 transition">üî≤
                        1:1</button>
                    <button onclick="customFormat()" id="fmtCustom"
                        class="flex-1 p-2 rounded-lg border border-white/10 text-[10px] font-bold text-gray-400 hover:bg-white/5 transition">‚öôÔ∏è
                        Custom</button>
                </div>

                <div class="p-3 bg-[#151517] rounded-xl border border-white/5 space-y-3">
                    <div class="grid grid-cols-5 gap-2">
                        <div class="col-span-1 relative group aspect-square">
                            <input type="color" id="bgColorPicker" value="#000000"
                                class="absolute inset-0 w-full h-full opacity-0 cursor-pointer"
                                oninput="setBackground('color', this.value)">
                            <div
                                class="w-full h-full rounded-lg border border-white/20 flex items-center justify-center bg-gradient-to-br from-gray-700 to-gray-900 group-hover:border-purple-500 transition">
                                <i data-lucide="palette" class="w-4 h-4 text-white"></i>
                            </div>
                        </div>
                        <button onclick="setBackground('color', '#000000')"
                            class="aspect-square rounded-lg bg-black border border-white/20 hover:scale-105 transition"></button>
                        <button onclick="setBackground('color', '#ffffff')"
                            class="aspect-square rounded-lg bg-white border border-white/20 hover:scale-105 transition"></button>
                        <button
                            onclick="setBackground('image', 'https://www.transparenttextures.com/patterns/cream-paper.png')"
                            class="aspect-square rounded-lg border border-white/20 hover:scale-105 transition relative overflow-hidden">
                            <img src="https://www.transparenttextures.com/patterns/cream-paper.png"
                                class="w-full h-full object-cover opacity-50">
                        </button>
                    </div>
                    <div class="flex gap-2">
                        <button onclick="document.getElementById('bgImgUpload').click()"
                            class="flex-1 py-2 rounded-lg bg-white/5 hover:bg-white/10 border border-white/10 text-[10px] flex items-center justify-center gap-2 transition">
                            <i data-lucide="image" class="w-3 h-3"></i> Base Img
                        </button>
                        <button onclick="document.getElementById('bgVidUpload').click()"
                            class="flex-1 py-2 rounded-lg bg-white/5 hover:bg-white/10 border border-white/10 text-[10px] flex items-center justify-center gap-2 transition">
                            <i data-lucide="video" class="w-3 h-3"></i> Base Vid
                        </button>
                    </div>
                    <input type="file" id="bgImgUpload" accept="image/*" onchange="handleBgUpload(this, 'image')">
                    <input type="file" id="bgVidUpload" accept="video/*" onchange="handleBgUpload(this, 'video')">
                </div>
            </div>

            <!-- 2. SCRIPT / STORYBOARD TOGGLE -->
            <div class="space-y-3">
                <div class="flex justify-between items-end">
                    <label class="text-[10px] font-bold text-gray-400 uppercase tracking-wider flex items-center gap-2">
                        <i data-lucide="clapperboard" class="w-3 h-3"></i> 2. Storyboard & Script
                    </label>

                    <div class="flex bg-black rounded-lg border border-white/10 p-0.5">
                        <button onclick="setEditorMode('script')" id="modeScript"
                            class="px-2 py-0.5 text-[9px] font-bold rounded bg-gray-700 text-white transition">üìù
                            Script</button>
                        <button onclick="setEditorMode('story')" id="modeStory"
                            class="px-2 py-0.5 text-[9px] font-bold rounded text-gray-500 hover:text-white transition">üé¨
                            Visual Storyboard</button>
                    </div>
                </div>

                <!-- RAW SCRIPT EDITOR -->
                <div id="rawScriptContainer">
                    <div class="flex gap-2 mb-2">
                        <select id="dictationLang" onchange="updateDictationLang()"
                            class="bg-[#151517] text-[10px] border border-white/10 rounded-lg p-1 text-gray-400 outline-none cursor-pointer hover:border-purple-500 transition">
                            <option value="en-US">üá∫üá∏ Eng</option>
                            <option value="kn-IN">üáÆüá≥ Kan</option>
                            <option value="hi-IN">üáÆüá≥ Hin</option>
                        </select>
                        <button onclick="toggleDictation()" id="micBtn"
                            class="text-[10px] px-3 py-1 bg-white/5 text-gray-300 border border-white/10 rounded-full hover:bg-white/10 flex items-center gap-1.5 transition">
                            <i data-lucide="mic" class="w-3 h-3"></i> Speak
                        </button>
                    </div>

                    <textarea id="scriptInput"
                        class="w-full bg-[#151517] border border-white/10 rounded-xl p-3 text-sm h-28 focus:border-purple-500 outline-none resize-none text-gray-200 font-medium placeholder-gray-600 leading-relaxed font-[Poppins] transition-all"
                        placeholder="Type here or use Storyboard..."></textarea>
                </div>

                <!-- STORYBOARD EDITOR -->
                <div id="storyboardContainer" class="hidden">
                    <button onclick="importScriptToStoryboard()"
                        class="w-full mb-2 py-1.5 bg-blue-900/30 border border-blue-600/30 text-blue-300 text-[10px] font-bold rounded hover:bg-blue-800 transition flex items-center justify-center gap-2">
                        <i data-lucide="import" class="w-3 h-3"></i> üì• Import Lines from Script
                    </button>
                    <div id="storyScenes" class="space-y-2 mb-2"></div>
                    <button onclick="addStoryScene()"
                        class="w-full py-2 bg-purple-600/20 border border-purple-500/50 text-purple-300 text-[10px] font-bold rounded-lg hover:bg-purple-600 hover:text-white transition flex items-center justify-center gap-2">
                        <i data-lucide="plus" class="w-3 h-3"></i> ADD NEW SCENE
                    </button>
                </div>

                <!-- DUAL ANIMATION DROPDOWNS -->
                <select id="animSelectClassic" onchange="STATE.animation = this.value"
                    class="w-full bg-[#151517] text-[11px] border border-white/10 rounded-lg p-2 outline-none text-purple-300 font-bold focus:border-purple-500 cursor-pointer mt-2">
                    <optgroup label="Global Default Animation">
                        <option value="elastic">üöÄ Elastic Pop (Default)</option>
                        <option value="kinetic">üí® Kinetic Whip</option>
                        <option value="slide">‚¨ÜÔ∏è Slide Up</option>
                        <option value="glitch">‚ö° Glitch</option>
                        <option value="cinema">üé¨ Cinema Fade</option>
                        <option value="spin">üå™Ô∏è Spin In</option>
                        <option value="zoom">üîé Zoom Slam</option>
                        <option value="drop">‚¨áÔ∏è Gravity Drop</option>
                        <option value="blur">üå´Ô∏è Blur Reveal</option>
                        <option value="shake">ü´® Shake Impact</option>
                        <option value="flip">üîÑ 3D Flip</option>
                        <option value="wave">üåä Gentle Wave</option>
                        <option value="mix" class="text-yellow-400">üîÄ Mix (Random)</option>
                    </optgroup>
                </select>

                <select id="animSelectPro" onchange="STATE.proAnimation = this.value"
                    class="hidden w-full bg-[#151517] text-[11px] border border-white/10 rounded-lg p-2 outline-none text-yellow-400 font-bold focus:border-yellow-500 cursor-pointer mt-2">
                    <optgroup label="Global Default Animation">
                        <option value="liquid">üíß Liquid Color Fill</option>
                        <option value="rgb">üî¥ RGB Chromatic Glitch</option>
                        <option value="reveal">ü™ü Cinematic Mask Reveal</option>
                        <option value="bounce">üèÄ Bouncy Gravity Drop</option>
                        <option value="hormozi">üî• Hormozi Pop</option>
                        <option value="squash">üí• Squash & Stretch</option>
                        <option value="marker">üñçÔ∏è Dynamic Highlighter</option>
                    </optgroup>
                </select>

                <div class="flex gap-2 items-center mt-2">
                    <select id="fontSelect"
                        class="flex-1 bg-[#151517] text-[11px] border border-white/10 rounded-lg p-2 outline-none text-gray-300">
                        <optgroup label="Kannada">
                            <option value="Noto Sans Kannada">Noto Sans</option>
                            <option value="Noto Serif Kannada">Noto Serif</option>
                            <option value="Baloo Tamma 2">Baloo Tamma</option>
                            <option value="Hubballi">Hubballi</option>
                            <option value="Tiro Kannada">Tiro Kannada</option>
                            <option value="Anek Kannada">Anek Kannada</option>
                        </optgroup>
                        <optgroup label="English">
                            <option value="Montserrat">Montserrat</option>
                            <option value="Poppins">Poppins</option>
                            <option value="Permanent Marker">Marker</option>
                        </optgroup>
                        <optgroup label="My Fonts" id="customFontGroup"></optgroup>
                    </select>
                    <button onclick="document.getElementById('fontUpload').click()"
                        class="p-2 bg-white/5 border border-white/10 rounded-lg hover:bg-white/10"
                        title="Upload Font"><i data-lucide="upload-cloud" class="w-4 h-4"></i></button>
                    <input type="file" id="fontUpload" accept=".ttf,.otf,.woff" onchange="handleFontUpload(this)">
                    <div class="color-wrapper" title="Text Color">
                        <div class="w-full h-full bg-white" id="mainColorPreview" style="background-color: #ffffff;">
                        </div><input type="color" value="#ffffff" oninput="updateColor('main', this.value)"
                            onchange="updateColor('main', this.value)">
                    </div>
                    <div class="color-wrapper" title="Highlight Color">
                        <div class="w-full h-full bg-red-500" id="highColorPreview" style="background-color: #ff3b3b;">
                        </div><input type="color" value="#ff3b3b" oninput="updateColor('high', this.value)"
                            onchange="updateColor('high', this.value)">
                    </div>
                </div>
            </div>

            <!-- 3. OVERLAY & ASSETS -->
            <div class="space-y-3">
                <label class="text-[10px] font-bold text-gray-400 uppercase tracking-wider flex items-center gap-2">
                    <i data-lucide="image" class="w-3 h-3"></i> 3. Assets, BG & B-Roll
                </label>
                <div class="grid grid-cols-2 gap-2">
                    <select id="textureSelect" onchange="updateTexture()"
                        class="bg-[#151517] border border-white/10 rounded-lg p-2 text-xs text-white outline-none">
                        <option value="none">No Overlay</option>
                        <option value="grid">üìê Dotted Grid (New!)</option>
                        <option value="paper">üìÑ Paper Texture</option>
                        <option value="crt">üì∫ CRT Scanlines</option>
                        <option value="noise">üå´Ô∏è Film Noise</option>
                    </select>
                    <button onclick="toggleSFX()" id="sfxBtn"
                        class="bg-green-500/10 border border-green-500/30 text-green-400 rounded-lg p-2 text-xs font-bold flex items-center justify-center gap-2 transition">
                        <i data-lucide="volume-2" class="w-3 h-3"></i> SFX: ON
                    </button>
                </div>
                <div class="flex gap-2">
                    <input type="text" id="assetName" placeholder="Keyword (e.g. vid1)"
                        class="flex-1 bg-[#151517] border border-white/10 rounded px-2 text-xs">
                    <button onclick="document.getElementById('assetUpload').click()"
                        class="bg-white/10 rounded px-3 py-1 text-xs border border-white/10 font-bold text-purple-400">Upload
                        Media</button>
                    <!-- ALLOW VIDEO IN ASSET UPLOAD FOR DYNAMIC BGS -->
                    <input type="file" id="assetUpload" accept="image/*,video/*" onchange="handleAssetUpload(this)">
                </div>

                <!-- NEW ASSET LIST GRID WITH INSERT BUTTONS -->
                <div id="assetList" class="flex flex-col gap-2 max-h-56 overflow-y-auto custom-scroll pr-1"></div>
            </div>

            <!-- 4. VOICE -->
            <div class="space-y-2">
                <label class="text-[10px] font-bold text-gray-400 uppercase tracking-wider flex items-center gap-2">
                    <i data-lucide="mic-2" class="w-3 h-3"></i> 4. Narrator
                </label>
                <div class="bg-[#151517] p-2 rounded-xl border border-white/10 space-y-2">

                    <!-- 5 TABS -->
                    <div class="flex overflow-x-auto border-b border-white/5 no-scrollbar pb-1 gap-1">
                        <button onclick="setVoiceMode('magic')" id="btnModeMagic"
                            class="px-3 py-1 text-[10px] font-bold transition tab-active text-yellow-400 whitespace-nowrap">‚ú®
                            Magic Bypass</button>
                        <button onclick="setVoiceMode('tts')" id="btnModeTTS"
                            class="px-3 py-1 text-[10px] font-bold transition tab-inactive whitespace-nowrap">ü§ñ
                            System</button>
                        <button onclick="setVoiceMode('rec')" id="btnModeRec"
                            class="px-3 py-1 text-[10px] font-bold transition tab-inactive whitespace-nowrap">üéôÔ∏è
                            Me</button>
                        <button onclick="setVoiceMode('eleven')" id="btnModeEleven"
                            class="px-3 py-1 text-[10px] font-bold transition tab-inactive text-purple-400 whitespace-nowrap">üß™
                            11Labs</button>
                        <button onclick="setVoiceMode('upload')" id="btnModeUpload"
                            class="px-3 py-1 text-[10px] font-bold transition tab-inactive whitespace-nowrap">üìÅ
                            Upload</button>
                    </div>

                    <!-- MAGIC CLOUD TTS CONTROLS -->
                    <div id="magicControls" class="space-y-2">
                        <div class="p-2 bg-yellow-500/10 border border-yellow-500/20 rounded-lg text-center">
                            <p class="text-[9px] text-yellow-200 mb-2"><strong>Mobile Bypass:</strong> Downloads real
                                audio files from the cloud so it can be recorded perfectly into your mobile video.</p>

                            <div class="flex gap-2 mb-2">
                                <select id="magicLang"
                                    class="flex-1 bg-black border border-white/10 rounded px-2 text-[10px] h-8 text-gray-300">
                                    <option value="en">English</option>
                                    <option value="kn">Kannada</option>
                                    <option value="hi">Hindi</option>
                                    <option value="te">Telugu</option>
                                    <option value="ta">Tamil</option>
                                    <option value="ml">Malayalam</option>
                                </select>
                            </div>

                            <button onclick="generateMagicAudio()" id="magicGenBtn"
                                class="w-full py-2 rounded-lg bg-yellow-600 text-black text-xs font-bold hover:bg-yellow-500 transition flex items-center justify-center gap-2">
                                ‚ú® GENERATE MAGIC AUDIO
                            </button>

                            <div id="magicPlayerContainer" class="hidden flex items-center gap-2 mt-2">
                                <audio id="magicAudioPreview" controls class="flex-1 h-8"></audio>
                                <span class="text-[9px] text-green-400 font-bold">READY</span>
                            </div>
                        </div>
                    </div>

                    <!-- TTS CONTROLS -->
                    <div id="ttsControls" class="hidden space-y-2">
                        <p class="text-[9px] text-red-400 text-center font-bold">Note: Cannot be exported to video on
                            Mobile.</p>
                        <div class="flex items-center gap-2">
                            <select id="voiceSelect"
                                class="flex-1 bg-black border border-white/10 rounded text-xs text-white p-2"></select>
                            <button onclick="loadVoices()"
                                class="bg-white/5 border border-white/10 p-2 rounded hover:bg-white/10"
                                title="Refresh Voices"><i data-lucide="refresh-cw" class="w-3 h-3"></i></button>
                        </div>
                        <div class="flex items-center gap-2">
                            <span class="text-[9px] text-gray-500">SPD</span>
                            <input type="range" id="speedRange" min="0.8" max="1.5" step="0.1" value="1.0"
                                class="flex-1 h-1 bg-gray-700 rounded-lg appearance-none cursor-pointer">
                        </div>
                    </div>

                    <!-- RECORDER CONTROLS -->
                    <div id="recControls" class="hidden space-y-2">
                        <div class="flex gap-2 mb-2">
                            <button onclick="setRecSubMode('scene')" id="subModeScene"
                                class="flex-1 py-1 text-[9px] rounded-md transition sub-tab-active">Scene-by-Scene</button>
                            <button onclick="setRecSubMode('continuous')" id="subModeCont"
                                class="flex-1 py-1 text-[9px] rounded-md transition sub-tab-inactive">Single
                                Take</button>
                        </div>

                        <!-- SCENE UI -->
                        <div id="sceneUI" class="space-y-2">
                            <div class="flex justify-between items-center mb-1">
                                <span class="text-[9px] text-gray-400 font-bold uppercase">Scene List</span>
                                <button onclick="generateSceneList()"
                                    class="text-[9px] text-purple-400 hover:text-purple-300">Refresh ‚Üª</button>
                            </div>
                            <div id="sceneListContainer" class="max-h-[150px] overflow-y-auto space-y-1 custom-scroll">
                                <div class="text-center text-[10px] text-gray-500 py-4">Click "Refresh" to load script
                                    lines.</div>
                            </div>
                        </div>

                        <!-- CONTINUOUS UI -->
                        <div id="continuousUI" class="hidden space-y-2">
                            <div id="prompterContainer"
                                class="hidden bg-[#1a1a1c] p-3 rounded-lg border border-white/10 mb-2">
                                <p class="text-[9px] text-gray-500 uppercase font-bold mb-1">Script to Read:</p>
                                <div id="prompterText"
                                    class="text-sm font-medium text-white leading-relaxed whitespace-pre-wrap h-32 overflow-y-auto custom-scroll">
                                </div>
                            </div>

                            <div class="p-3 bg-black/20 rounded-lg border border-white/5 text-center space-y-2">
                                <div class="flex gap-2">
                                    <button id="contRecBtn" onclick="toggleContinuousRecord()"
                                        class="flex-1 py-3 rounded-xl bg-red-600/20 text-red-500 border border-red-600/50 hover:bg-red-600 hover:text-white transition font-bold flex items-center justify-center gap-2">
                                        <i data-lucide="mic" class="w-4 h-4"></i> RECORD
                                    </button>
                                    <button id="contPauseBtn" onclick="togglePauseCont()"
                                        class="hidden w-1/3 py-3 rounded-xl bg-yellow-600/20 text-yellow-500 border border-yellow-600/50 hover:bg-yellow-600 hover:text-white transition font-bold flex items-center justify-center gap-2">
                                        <i data-lucide="pause" class="w-4 h-4"></i>
                                    </button>
                                </div>
                                <div id="contAudioPlayer" class="hidden flex items-center gap-2 mt-2">
                                    <audio id="contAudioEl" controls class="h-8 flex-1 w-full"></audio>
                                    <button onclick="deleteContinuousAudio()"
                                        class="p-2 text-red-400 hover:text-red-300"><i data-lucide="trash-2"
                                            class="w-4 h-4"></i></button>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- ELEVENLABS CONTROLS -->
                    <div id="elevenControls" class="hidden space-y-2">
                        <div class="flex gap-2">
                            <input type="password" id="elevenApiKey" placeholder="Paste API Key"
                                class="flex-1 bg-black border border-white/10 rounded px-2 text-[10px] h-8">
                            <button onclick="saveElevenKey()"
                                class="bg-purple-600/20 text-purple-400 border border-purple-600/50 px-3 rounded text-[10px] font-bold hover:bg-purple-600 hover:text-white transition">Save</button>
                        </div>
                        <div class="flex gap-2">
                            <select id="elevenVoiceSelect"
                                class="flex-1 bg-black border border-white/10 rounded px-2 text-[10px] h-8 text-gray-300">
                                <option value="">Select Voice...</option>
                            </select>
                            <button onclick="fetchElevenVoices()"
                                class="bg-white/5 border border-white/10 px-2 rounded hover:bg-white/10"
                                title="Refresh Voices"><i data-lucide="refresh-cw" class="w-3 h-3"></i></button>
                        </div>
                        <button onclick="generateElevenAudio()" id="elGenBtn"
                            class="w-full py-2 rounded-lg bg-gradient-to-r from-purple-600 to-indigo-600 text-white text-xs font-bold hover:shadow-lg hover:shadow-purple-500/20 transition flex items-center justify-center gap-2">
                            <i data-lucide="sparkles" class="w-3 h-3"></i> GENERATE AUDIO
                        </button>
                        <div id="elevenPlayerContainer" class="hidden flex items-center gap-2">
                            <audio id="elevenAudioPreview" controls class="flex-1 h-8"></audio>
                            <span class="text-[9px] text-green-400 font-bold">READY</span>
                        </div>
                    </div>

                    <!-- UPLOAD CONTROLS -->
                    <div id="uploadControls" class="hidden space-y-2">
                        <div class="p-3 bg-black/20 rounded-lg border border-white/5 text-center space-y-2">
                            <input type="file" id="uploadAudioInput" accept="audio/*"
                                onchange="handleAudioUpload(this)">
                            <button onclick="document.getElementById('uploadAudioInput').click()"
                                class="w-full py-3 rounded-xl bg-blue-600/20 text-blue-400 border border-blue-600/50 hover:bg-blue-600 hover:text-white transition font-bold flex items-center justify-center gap-2">
                                <i data-lucide="upload" class="w-4 h-4"></i> CHOOSE AUDIO FILE
                            </button>
                            <div id="uploadAudioPlayerContainer" class="hidden flex items-center gap-2 mt-2">
                                <audio id="uploadAudioPreview" controls class="h-8 flex-1 w-full"></audio>
                                <button onclick="deleteUploadedAudio()" class="p-2 text-red-400 hover:text-red-300"><i
                                        data-lucide="trash-2" class="w-4 h-4"></i></button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

        </div>

        <!-- FOOTER -->
        <div class="p-4 md:p-5 border-t border-white/10 bg-[#0f0f11] space-y-2 shrink-0">
            <button onclick="togglePreview()" id="playBtn"
                class="w-full bg-white text-black font-black py-3 rounded-xl text-xs flex items-center justify-center gap-2 hover:bg-gray-200 transition">
                <i data-lucide="play" class="w-3 h-3"></i> PREVIEW
            </button>
            <button id="exportVideoBtn" onclick="exportWithAudio()"
                class="w-full bg-purple-600 text-white font-bold py-3 rounded-xl text-xs flex items-center justify-center gap-2 hover:bg-purple-500 transition">
                <i data-lucide="download" class="w-3 h-3"></i> EXPORT VIDEO
            </button>
        </div>
    </div>

    <!-- CANVAS AREA -->
    <div
        class="h-[45%] w-full md:flex-1 md:h-full bg-[#0a0a0a] relative flex items-center justify-center p-2 md:p-8 bg-[radial-gradient(#222_1px,transparent_1px)] bg-[size:24px_24px] overflow-hidden">
        <div id="canvasContainer" class="relative shadow-2xl border border-white/10 bg-black overflow-hidden"
            style="width: 360px; height: 640px; transform-origin: center;">
            <div id="bgLayer" class="absolute inset-0 z-0">
                <img id="bgImgDisplay" class="w-full h-full object-cover hidden" crossorigin="anonymous">
                <video id="bgVidDisplay" class="w-full h-full object-cover hidden" loop muted playsinline
                    crossorigin="anonymous"></video>
                <div id="bgColorDisplay" class="w-full h-full hidden"></div>
            </div>
            <div id="textureOverlay" class="absolute inset-0 pointer-events-none z-10 opacity-30 hidden"></div>
            <canvas id="mainCanvas" class="w-full h-full block relative z-20"></canvas>
        </div>
    </div>

    <!-- AUDIO POOL -->
    <!-- Replaced broken Mixkit links with empty src to prevent 403 errors. User can implement local sounds later. -->
    <audio id="sfxPop" src="" crossorigin="anonymous"></audio>
    <audio id="sfxWhoosh" src="" crossorigin="anonymous"></audio>
    <audio id="sfxClick" src="" crossorigin="anonymous"></audio>

    <script>
        lucide.createIcons();
        const canvas = document.getElementById('mainCanvas');
        const ctx = canvas.getContext('2d');
        // INCREASED SCALE for 1080p Export Quality (360 * 3 = 1080)
        const SCALE = 3;

        // STATE
        const STATE = {
            appMode: 'classic',
            editorMode: 'script', // 'script' or 'story'
            storyScenes: [], // Array of {bg: '', broll: '', align: '', text: ''}
            format: { w: 360, h: 640, pad: 30, fontSize: 40, raw: '9:16' },
            isPlaying: false, objects: [], layout: [], wordIndex: 0,
            colors: { main: '#ffffff', high: '#ff3b3b' }, assets: {}, assetTypes: {}, sfxEnabled: true,
            animation: 'elastic', proAnimation: 'liquid', bgType: 'color', bgValue: '#000000',
            baseBgType: 'color', baseBgValue: '#000000', currentDynamicBg: null,
            isRecording: false, recognition: null,
            voiceMode: 'magic',
            recMode: 'scene',
            sceneAudios: {},
            continuousBlob: null,
            activeRecorder: null, recordingIndex: null, isContRecording: false, isContPaused: false,
            elevenKey: localStorage.getItem('eleven_key') || '',
            elevenVoices: [],
            isFallbackPlaying: false,
            isExporting: false,
            playbackProgress: 0,
            isFinishing: false,
            dictationBaseline: '',
            particles: [],
            screenShake: 0,
            globalZoom: 0,
            proPhrases: [],
            proAudioTime: 0,
            activePins: [],
            activeCenterBrolls: [],
            imageCache: {}
        };

        const paperTexture = new Image();
        paperTexture.crossOrigin = 'anonymous';
        // paperTexture.src = 'https://www.transparenttextures.com/patterns/cream-paper.png'; // BLOCKED

        // Secure Global Helper
        STATE.getNoiseCanvas = function (w, h) {
            if (!STATE.noiseCanvas || STATE.noiseCanvas.width !== w) {
                STATE.noiseCanvas = document.createElement('canvas');
                STATE.noiseCanvas.width = w; STATE.noiseCanvas.height = h;
                const nctx = STATE.noiseCanvas.getContext('2d');
                const imgData = nctx.createImageData(w, h);
                const data = imgData.data;
                for (let i = 0; i < data.length; i += 4) {
                    const c = Math.random() * 255;
                    data[i] = c; data[i + 1] = c; data[i + 2] = c; data[i + 3] = 15;
                }
                nctx.putImageData(imgData, 0, 0);
            }
            return STATE.noiseCanvas;
        }

        // Smart Cache Retrieval
        function getCachedImage(key) {
            if (!STATE.assets[key]) return null;
            if (!STATE.imageCache[key]) {
                const img = new Image();
                img.src = STATE.assets[key];
                STATE.imageCache[key] = img;
            }
            return STATE.imageCache[key];
        }

        function init() {
            resizeCanvas(); loadVoices(); loadAssets(); loadSavedFonts();
            if (speechSynthesis.onvoiceschanged !== undefined) speechSynthesis.onvoiceschanged = loadVoices;
            setBackground('color', '#000000');
            if (STATE.elevenKey) document.getElementById('elevenApiKey').value = STATE.elevenKey;

            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry/i.test(navigator.userAgent) || window.innerWidth < 768;
            if (isMobile) setVoiceMode('magic'); else setVoiceMode('tts');

            setAppMode('classic');
            loop();
        }

        // --- VISUAL EDITOR HELPERS (SMART INSERT) ---
        function insertTag(tag) {
            if (STATE.editorMode === 'story') {
                if (STATE.storyScenes.length === 0) addStoryScene();
                const lastIdx = STATE.storyScenes.length - 1;

                if (tag.startsWith('[bg=')) {
                    const key = tag.substring(4, tag.length - 1);
                    updateStoryScene(lastIdx, 'bg', key);
                    renderStoryboard();
                } else if (tag.startsWith('[=')) {
                    const key = tag.substring(2, tag.length - 1);
                    updateStoryScene(lastIdx, 'broll', key);
                    renderStoryboard();
                } else {
                    // Append text/pin tags to current scene text
                    const currentText = STATE.storyScenes[lastIdx].text;
                    updateStoryScene(lastIdx, 'text', currentText + (currentText ? " " : "") + tag);
                    renderStoryboard();
                }
            } else {
                // Raw Script Mode
                const textarea = document.getElementById('scriptInput');
                const start = textarea.selectionStart;
                const end = textarea.selectionEnd;
                const text = textarea.value;
                const pad = (start > 0 && text[start - 1] !== ' ' && text[start - 1] !== '\n') ? ' ' : '';
                textarea.value = text.substring(0, start) + pad + tag + " " + text.substring(end);
                textarea.focus();
                const newCursor = start + pad.length + tag.length + 1;
                textarea.setSelectionRange(newCursor, newCursor);
            }
        }

        function wrapText(startTag, endTag) {
            const textarea = document.getElementById('scriptInput');
            const start = textarea.selectionStart;
            const end = textarea.selectionEnd;
            const text = textarea.value;

            if (start === end) {
                // No selection, just insert placeholder
                const placeholder = "text";
                textarea.value = text.substring(0, start) + startTag + placeholder + endTag + text.substring(end);
                textarea.focus();
                textarea.setSelectionRange(start + startTag.length, start + startTag.length + placeholder.length);
            } else {
                // Wrap selection
                const selected = text.substring(start, end);
                textarea.value = text.substring(0, start) + startTag + selected + endTag + text.substring(end);
                textarea.focus();
                textarea.setSelectionRange(end + startTag.length + endTag.length, end + startTag.length + endTag.length);
            }
        }

        // --- EDITOR MODE SWITCHER ---
        function setEditorMode(mode) {
            STATE.editorMode = mode;
            const btnScript = document.getElementById('modeScript');
            const btnStory = document.getElementById('modeStory');
            const contScript = document.getElementById('rawScriptContainer');
            const contStory = document.getElementById('storyboardContainer');

            if (mode === 'script') {
                btnScript.className = "px-2 py-0.5 text-[9px] font-bold rounded bg-gray-700 text-white transition";
                btnStory.className = "px-2 py-0.5 text-[9px] font-bold rounded text-gray-500 hover:text-white transition";
                contScript.classList.remove('hidden');
                contStory.classList.add('hidden');
                compileStoryToScript();
            } else {
                btnScript.className = "px-2 py-0.5 text-[9px] font-bold rounded text-gray-500 hover:text-white transition";
                btnStory.className = "px-2 py-0.5 text-[9px] font-bold rounded bg-purple-700 text-white transition";
                contScript.classList.add('hidden');
                contStory.classList.remove('hidden');
                renderStoryboard();
            }
        }

        // --- STORYBOARD LOGIC ---
        function importScriptToStoryboard() {
            const raw = document.getElementById('scriptInput').value;
            const lines = raw.split('\n');
            STATE.storyScenes = [];

            lines.forEach(line => {
                if (!line.trim()) return; // Skip empty lines

                let bg = "";
                let broll = "";
                let align = "center";
                let text = line;

                // Extract BG
                const bgMatch = text.match(/\[bg=(.*?)\]/i);
                if (bgMatch) { bg = bgMatch[1]; text = text.replace(bgMatch[0], ''); }

                // Extract B-Roll (Center or Pin)
                const centerMatch = text.match(/\[=(.*?)\]/i);
                if (centerMatch) { broll = centerMatch[1]; text = text.replace(centerMatch[0], ''); }
                // Note: Currently Storyboard only has one B-Roll slot. Let's map [=...] to it. 
                // If [+...] is used, maybe map to same slot or ignore for simplicity to keep it user friendly? 
                // The user asked for "simple". Let's stick to Center B-Roll [=...] as the primary B-Roll in storyboard.

                // Extract Align
                if (text.includes('[top]')) { align = 'top'; text = text.replace('[top]', ''); }
                if (text.includes('[bottom]')) { align = 'bottom'; text = text.replace('[bottom]', ''); }

                // Cleanup text
                text = text.trim();

                // Add scene with ALL properties including timeline controls
                STATE.storyScenes.push({
                    bg,
                    bgColor: '#000000',
                    broll,
                    align,
                    text,
                    duration: null,
                    durationMode: 'auto',
                    brollStart: 0,
                    brollDuration: 2,
                    brollFade: true,
                    brollPreset: 'full'
                });
            });

            renderStoryboard();
        }

        function addNewStoryScene() {
            STATE.storyScenes.push({
                bg: '',
                bgColor: '#000000',  // Solid color background option
                broll: '',
                align: 'center',
                text: '',
                // Timeline control properties
                duration: null,
                durationMode: 'auto',
                brollStart: 0,
                brollDuration: 2,
                brollFade: true,
                brollPreset: 'full',
                // Advanced layout properties
                layoutMode: 'text-over-media',  // 'text-over-media', 'media-only', 'text-only', 'text-below-media'
                textSize: 'normal'  // 'small', 'normal', 'large', 'huge'
            });
            renderStoryboard();
        }

        function deleteStoryScene(index) {
            STATE.storyScenes.splice(index, 1);
            renderStoryboard();
        }

        function splitStoryScene(index) {
            const scene = STATE.storyScenes[index];
            const text = scene.text || "";
            // Split by sentence ending punctuation
            const parts = text.split(/([.!?‡•§‡••]\s+)/).filter(p => p.trim() !== "");

            if (parts.length <= 1) return; // Nothing to split

            // Remove original scene
            STATE.storyScenes.splice(index, 1);

            // Insert new scenes
            let insertIdx = index;
            let buffer = "";
            parts.forEach(part => {
                // Re-attach punctuation if split removed it? Actually split keeps separator in capture group if () used.
                // Simple approach: if part is just punctuation/space, append to prev buffer.
                if (part.match(/^[.!?‡•§‡••]\s*$/)) {
                    if (insertIdx > index) { // Append to last inserted scene
                        STATE.storyScenes[insertIdx - 1].text += part;
                    } else {
                        buffer += part;
                    }
                } else {
                    STATE.storyScenes.splice(insertIdx, 0, {
                        bg: scene.bg, // Inherit BG
                        broll: "", // Don't inherit B-Roll (usually B-Roll is for one specific moment)
                        align: scene.align,
                        text: buffer + part
                    });
                    buffer = "";
                    insertIdx++;
                }
            });
            renderStoryboard();
        }

        function updateStoryScene(index, field, value) {
            if (!STATE.storyScenes[index]) return;

            // Prevent duplicate updates
            const currentValue = STATE.storyScenes[index][field];
            if (currentValue === value) return;

            STATE.storyScenes[index][field] = value;
            compileStoryToScript();
            if (field !== 'text') renderStoryboard(); // Avoid re-render on every text keystroke
        }

        function renderStoryboard() {
            const container = document.getElementById('storyScenes');
            container.innerHTML = '';

            if (STATE.storyScenes.length === 0) {
                container.innerHTML = `<div class="text-center text-xs text-gray-500 py-4">No scenes yet. Click 'Add New Scene'.</div>`;
                return;
            }

            let bgOptions = '<option value="">(Keep Prev BG)</option>';
            let brollOptions = '<option value="">(None)</option>';
            Object.keys(STATE.assets).forEach(k => {
                bgOptions += `<option value="${k}">${k}</option>`;
                brollOptions += `<option value="${k}">${k}</option>`;
            });

            STATE.storyScenes.forEach((scene, i) => {
                const div = document.createElement('div');
                div.className = 'scene-card';

                // Build asset preview section
                let assetPreview = '';
                const sceneAssets = [];

                // Add BG asset if exists
                if (scene.bg && STATE.assets[scene.bg]) {
                    const isVid = STATE.assetTypes[scene.bg] === 'video';
                    const icon = isVid ? 'üé•' : 'üì∑';
                    const mediaSrc = STATE.assets[scene.bg];
                    sceneAssets.push({ type: 'bg', key: scene.bg, isVid, icon, mediaSrc });
                }

                // Add B-Roll asset if exists
                if (scene.broll && STATE.assets[scene.broll]) {
                    const isVid = STATE.assetTypes[scene.broll] === 'video';
                    const icon = isVid ? 'üé•' : 'üì∑';
                    const mediaSrc = STATE.assets[scene.broll];
                    sceneAssets.push({ type: 'broll', key: scene.broll, isVid, icon, mediaSrc });
                }

                if (sceneAssets.length > 0) {
                    assetPreview = '<div class="flex gap-2 mb-2 flex-wrap">';
                    sceneAssets.forEach(asset => {
                        const mediaHtml = asset.isVid
                            ? `<video src="${asset.mediaSrc}" class="w-full h-full object-cover rounded"></video>`
                            : `<img src="${asset.mediaSrc}" class="w-full h-full object-cover rounded">`;
                        assetPreview += `
                            <div class="relative bg-black border border-purple-500/30 rounded overflow-hidden" style="width: 60px; height: 60px;">
                                ${mediaHtml}
                                <div class="absolute top-0 left-0 bg-purple-600 text-white text-[7px] px-1 rounded-br">${asset.type === 'bg' ? 'BG' : 'B-Roll'}</div>
                                <div class="absolute bottom-0 right-0 flex gap-0.5 p-0.5">
                                    <button onclick="replaceSceneAsset(${i}, '${asset.key}', '${asset.type}')" class="bg-blue-600/90 hover:bg-blue-500 text-white rounded p-0.5" title="Replace">
                                        <i data-lucide="refresh-cw" class="w-2.5 h-2.5"></i>
                                    </button>
                                    <button onclick="deleteSceneAsset(${i}, '${asset.key}', '${asset.type}')" class="bg-red-600/90 hover:bg-red-500 text-white rounded p-0.5" title="Delete">
                                        <i data-lucide="x" class="w-2.5 h-2.5"></i>
                                    </button>
                                </div>
                            </div>
                        `;
                    });
                    assetPreview += '</div>';
                }

                div.innerHTML = `
                    <div class="scene-header">
                        <span class="scene-label">Scene ${i + 1}</span>
                        <div class="split-btn" onclick="splitStoryScene(${i})" title="Split text into multiple scenes">‚úÇÔ∏è Split</div>
                    </div>
                    <!-- Background -->
                    <div class="mb-2">
                        <div class="flex items-center gap-1 mb-1">
                            <label class="text-[8px] text-gray-500 uppercase">Background</label>
                            <button onclick="uploadSceneAsset(${i}, 'bg')" class="ml-auto text-[8px] px-2 py-0.5 bg-indigo-900/40 text-indigo-300 rounded border border-indigo-700/40 hover:bg-indigo-600 hover:text-white transition flex items-center gap-1" title="Upload Background">
                                <i data-lucide="upload" class="w-2.5 h-2.5"></i> Upload
                            </button>
                        </div>
                        <div class="flex gap-1">
                            <select class="scene-select flex-1" onchange="updateStoryScene(${i}, 'bg', this.value)">
                                ${bgOptions}
                            </select>
                            <input type="color" 
                                class="w-10 h-8 rounded border border-white/20 cursor-pointer bg-transparent" 
                                value="${scene.bgColor || '#000000'}"
                                onchange="updateSceneBgColor(${i}, this.value)"
                                title="Pick solid color">
                        </div>
                    </div>
                    
                    <div class="mb-2">
                        <div class="flex items-center gap-1 mb-1">
                            <label class="text-[8px] text-gray-500 uppercase">B-Roll</label>
                            <button onclick="uploadSceneAsset(${i}, 'broll')" class="ml-auto text-[8px] px-2 py-0.5 bg-green-900/40 text-green-300 rounded border border-green-700/40 hover:bg-green-600 hover:text-white transition flex items-center gap-1" title="Upload B-Roll">
                                <i data-lucide="upload" class="w-2.5 h-2.5"></i> Upload
                            </button>
                        </div>
                        <select class="scene-select" onchange="updateStoryScene(${i}, 'broll', this.value)">
                            ${brollOptions}
                        </select>
                    </div>
                    
                    <!-- Timeline Controls -->
                    <div class="mt-2 p-2 bg-black/30 rounded border border-cyan-900/30">
                        <div class="text-[8px] text-cyan-400 uppercase mb-1.5 flex items-center gap-1">
                            <i data-lucide="clock" class="w-2.5 h-2.5"></i>
                            Timeline
                        </div>
                        
                        <!-- Scene Duration -->
                        <div class="mb-2">
                            <div class="flex items-center gap-2 mb-1">
                                <label class="text-[8px] text-gray-400 flex-shrink-0">Duration:</label>
                                <select class="scene-select flex-1 text-[9px]" onchange="updateSceneDurationMode(${i}, this.value)">
                                    <option value="auto" ${!scene.durationMode || scene.durationMode === 'auto' ? 'selected' : ''}>Auto (from voice)</option>
                                    <option value="manual" ${scene.durationMode === 'manual' ? 'selected' : ''}>Manual</option>
                                </select>
                                <input type="number" step="0.1" min="0.1" max="60" 
                                    class="scene-select w-14 text-[9px]" 
                                    placeholder="3.0" 
                                    value="${scene.duration || ''}"
                                    ${scene.durationMode !== 'manual' ? 'disabled' : ''}
                                    onchange="updateSceneDuration(${i}, this.value)" />
                                <span class="text-[8px] text-gray-500">s</span>
                            </div>
                        </div>
                        
                        <!-- B-Roll Timing (Simplified) -->
                        ${scene.broll ? `
                        <div class="mb-1">
                            <div class="flex items-center gap-2">
                                <label class="text-[8px] text-gray-400 flex-shrink-0">B-Roll Show:</label>
                                <select class="scene-select flex-1 text-[9px]" onchange="updateBrollPreset(${i}, this.value)">
                                    <option value="full" ${!scene.brollPreset || scene.brollPreset === 'full' ? 'selected' : ''}>üìΩÔ∏è Full Scene</option>
                                    <option value="first-half" ${scene.brollPreset === 'first-half' ? 'selected' : ''}>‚èÆÔ∏è First Half</option>
                                    <option value="second-half" ${scene.brollPreset === 'second-half' ? 'selected' : ''}>‚è≠Ô∏è Second Half</option>
                                    <option value="custom" ${scene.brollPreset === 'custom' ? 'selected' : ''}>‚öôÔ∏è Custom</option>
                                </select>
                            </div>
                            ${scene.brollPreset === 'custom' ? `
                            <div class="flex items-center gap-1 mt-1 ml-4">
                                <span class="text-[7px] text-gray-500">Start</span>
                                <input type="number" step="0.1" min="0" 
                                    class="scene-select w-12 text-[8px]" 
                                    value="${scene.brollStart || 0}"
                                    onchange="updateBrollTiming(${i}, 'start', this.value)" />
                                <span class="text-[7px] text-gray-500">Len</span>
                                <input type="number" step="0.1" min="0.1" 
                                    class="scene-select w-12 text-[8px]" 
                                    value="${scene.brollDuration || 2}"
                                    onchange="updateBrollTiming(${i}, 'duration', this.value)" />
                                <span class="text-[7px] text-gray-500">s</span>
                            </div>
                            ` : ''}
                        </div>
                        ` : ''}
                    </div>
                    
                    ${assetPreview}
                    
                    <textarea class="w-full bg-black border border-white/10 rounded p-2 text-sm text-white mb-2" rows="2" placeholder="Dialogue..." oninput="updateStoryScene(${i}, 'text', this.value)">${scene.text}</textarea>
                    
                    <!-- Advanced Layout Controls -->
                    <div class="mb-2 p-2 bg-black/20 rounded border border-purple-900/30">
                        <div class="text-[8px] text-purple-400 uppercase mb-1.5 flex items-center gap-1">
                            <i data-lucide="layout" class="w-2.5 h-2.5"></i>
                            Layout & Size
                        </div>
                        <div class="grid grid-cols-2 gap-2">
                            <div>
                                <label class="text-[7px] text-gray-400 block mb-0.5">Layout Mode</label>
                                <select class="scene-select text-[8px]" onchange="updateSceneLayout(${i}, this.value)">
                                    <option value="text-over-media" ${!scene.layoutMode || scene.layoutMode === 'text-over-media' ? 'selected' : ''}>üìù Text Over Media</option>
                                    <option value="media-only" ${scene.layoutMode === 'media-only' ? 'selected' : ''}>üé¨ Media Only</option>
                                    <option value="text-only" ${scene.layoutMode === 'text-only' ? 'selected' : ''}>üí¨ Text Only</option>
                                    <option value="text-below-media" ${scene.layoutMode === 'text-below-media' ? 'selected' : ''}>üìê Text Below Media</option>
                                </select>
                            </div>
                            <div>
                                <label class="text-[7px] text-gray-400 block mb-0.5">Text Size</label>
                                <select class="scene-select text-[8px]" onchange="updateTextSize(${i}, this.value)">
                                    <option value="small" ${scene.textSize === 'small' ? 'selected' : ''}>üî§ Small (50%)</option>
                                    <option value="normal" ${!scene.textSize || scene.textSize === 'normal' ? 'selected' : ''}>üî° Normal</option>
                                    <option value="large" ${scene.textSize === 'large' ? 'selected' : ''}>üî† Large (150%)</option>
                                    <option value="huge" ${scene.textSize === 'huge' ? 'selected' : ''}>üì¢ Huge (200%)</option>
                                </select>
                            </div>
                        </div>
                    </div>
                    
                    <div class="flex gap-1 items-center">
                         <div class="flex bg-black rounded p-0.5 border border-white/10">
                            <button onclick="updateStoryScene(${i}, 'align', 'top'); renderStoryboard();" class="scene-btn ${scene.align === 'top' ? 'active' : ''}">Top</button>
                            <button onclick="updateStoryScene(${i}, 'align', 'center'); renderStoryboard();" class="scene-btn ${scene.align === 'center' ? 'active' : ''}">Mid</button>
                            <button onclick="updateStoryScene(${i}, 'align', 'bottom'); renderStoryboard();" class="scene-btn ${scene.align === 'bottom' ? 'active' : ''}">Bot</button>
                         </div>
                         <button onclick="deleteStoryScene(${i})" class="ml-auto text-red-400 hover:text-red-300 text-xs p-1"><i data-lucide="trash-2" class="w-3 h-3"></i></button>
                    </div>
                `;
                // Hydrate select values manually after creation
                const selects = div.querySelectorAll('select');
                selects[0].value = scene.bg;
                selects[1].value = scene.broll;

                container.appendChild(div);
            });
            lucide.createIcons();
        }

        function compileStoryToScript() {
            let fullScript = "";
            STATE.storyScenes.forEach((scene, i) => {
                let tags = "";

                // Background (color or asset)
                if (scene.bgColor && scene.bgColor !== '#000000' && !scene.bg) {
                    tags += `[bg=${scene.bgColor}] `;
                } else if (scene.bg) {
                    tags += `[bg=${scene.bg}] `;
                }

                // Alignment
                if (scene.align === 'top') tags += `[top] `;
                if (scene.align === 'bottom') tags += `[bottom] `;
                if (scene.align === 'left') tags += `[left] `;
                if (scene.align === 'right') tags += `[right] `;

                // Layout mode (for internal use)
                if (scene.layoutMode && scene.layoutMode !== 'text-over-media') {
                    STATE.storyScenes[i]._layoutMode = scene.layoutMode; // Store for playback
                }

                // Text size (for internal use)
                if (scene.textSize && scene.textSize !== 'normal') {
                    STATE.storyScenes[i]._textSize = scene.textSize; // Store for playback
                }

                let brollTag = "";
                if (scene.broll) brollTag = ` [=${scene.broll}]`;

                let content = scene.text.trim();
                // Add gap automatically if text empty but B-Roll present
                if (!content && scene.broll) content = "_";

                fullScript += `${tags}${content}${brollTag}\n`;
            });
            document.getElementById('scriptInput').value = fullScript;
        }

        // --- PER-SCENE ASSET MANAGEMENT HELPERS ---
        function uploadSceneAsset(sceneIndex, assetType) {
            // assetType: 'bg' or 'broll'
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'image/*,video/*';
            input.onchange = async (e) => {
                const file = e.target.files[0];
                if (!file) return;

                // Auto-generate unique asset key
                const timestamp = Date.now();
                const assetKey = `s${sceneIndex + 1}_${assetType}_${timestamp}`;

                // Upload to global asset library
                if (file.type.startsWith('video/')) {
                    STATE.assets[assetKey] = URL.createObjectURL(file);
                    STATE.assetTypes[assetKey] = 'video';
                    STATE.imageCache[assetKey] = null;

                    // Preload video element
                    if (!document.getElementById('dyn_vid_' + assetKey)) {
                        let v = document.createElement('video');
                        v.id = 'dyn_vid_' + assetKey;
                        v.src = STATE.assets[assetKey];
                        v.muted = true;
                        v.loop = true;
                        v.playsInline = true;
                        v.style.display = 'none';
                        v.preload = 'auto';
                        document.body.appendChild(v);
                    }
                } else {
                    // Image upload
                    const reader = new FileReader();
                    reader.onload = (ev) => {
                        STATE.assets[assetKey] = ev.target.result;
                        STATE.assetTypes[assetKey] = 'image';
                        STATE.imageCache[assetKey] = null;
                        saveAssets();

                        // Assign to scene
                        if (assetType === 'bg') {
                            STATE.storyScenes[sceneIndex].bg = assetKey;
                        } else {
                            STATE.storyScenes[sceneIndex].broll = assetKey;
                        }

                        compileStoryToScript();
                        renderStoryboard();
                        renderAssets(); // Update global asset list
                    };
                    reader.readAsDataURL(file);
                    return; // Exit early for image (async callback handles the rest)
                }

                // For video (synchronous path)
                if (assetType === 'bg') {
                    STATE.storyScenes[sceneIndex].bg = assetKey;
                } else {
                    STATE.storyScenes[sceneIndex].broll = assetKey;
                }

                compileStoryToScript();
                renderStoryboard();
                renderAssets(); // Update global asset list
            };
            input.click();
        }

        function deleteSceneAsset(sceneIndex, assetKey, assetType) {
            if (!confirm(`Remove this ${assetType === 'bg' ? 'background' : 'b-roll'} from the scene?`)) return;

            // Clear from scene
            if (assetType === 'bg') {
                STATE.storyScenes[sceneIndex].bg = '';
            } else {
                STATE.storyScenes[sceneIndex].broll = '';
            }

            // Optionally delete from global library if not used elsewhere
            const isUsedElsewhere = STATE.storyScenes.some((scene, idx) => {
                if (idx === sceneIndex) return false; // Skip current scene
                return scene.bg === assetKey || scene.broll === assetKey;
            });

            if (!isUsedElsewhere) {
                // Asset not used in any other scene, safe to delete from global library
                delete STATE.assets[assetKey];
                delete STATE.imageCache[assetKey];
                delete STATE.assetTypes[assetKey];
                const v = document.getElementById('dyn_vid_' + assetKey);
                if (v) {
                    v.pause();
                    v.removeAttribute('src');
                    v.load();
                    v.remove();
                }
                saveAssets();
            }

            compileStoryToScript();
            renderStoryboard();
            renderAssets();
        }

        function replaceSceneAsset(sceneIndex, oldAssetKey, assetType) {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'image/*,video/*';
            input.onchange = async (e) => {
                const file = e.target.files[0];
                if (!file) return;

                // Check if old asset is used elsewhere
                const isOldUsedElsewhere = STATE.storyScenes.some((scene, idx) => {
                    if (idx === sceneIndex) return false; // Skip current scene
                    return scene.bg === oldAssetKey || scene.broll === oldAssetKey;
                });

                // If old asset not used elsewhere, delete it
                if (!isOldUsedElsewhere) {
                    delete STATE.assets[oldAssetKey];
                    delete STATE.imageCache[oldAssetKey];
                    delete STATE.assetTypes[oldAssetKey];
                    const v = document.getElementById('dyn_vid_' + oldAssetKey);
                    if (v) {
                        v.pause();
                        v.removeAttribute('src');
                        v.load();
                        v.remove();
                    }
                }

                // Upload new asset
                const timestamp = Date.now();
                const newAssetKey = `s${sceneIndex + 1}_${assetType}_${timestamp}`;

                if (file.type.startsWith('video/')) {
                    STATE.assets[newAssetKey] = URL.createObjectURL(file);
                    STATE.assetTypes[newAssetKey] = 'video';
                    STATE.imageCache[newAssetKey] = null;

                    if (!document.getElementById('dyn_vid_' + newAssetKey)) {
                        let v = document.createElement('video');
                        v.id = 'dyn_vid_' + newAssetKey;
                        v.src = STATE.assets[newAssetKey];
                        v.muted = true;
                        v.loop = true;
                        v.playsInline = true;
                        v.style.display = 'none';
                        v.preload = 'auto';
                        document.body.appendChild(v);
                    }
                } else {
                    const reader = new FileReader();
                    reader.onload = (ev) => {
                        STATE.assets[newAssetKey] = ev.target.result;
                        STATE.assetTypes[newAssetKey] = 'image';
                        STATE.imageCache[newAssetKey] = null;
                        saveAssets();

                        // Assign new asset to scene
                        if (assetType === 'bg') {
                            STATE.storyScenes[sceneIndex].bg = newAssetKey;
                        } else {
                            STATE.storyScenes[sceneIndex].broll = newAssetKey;
                        }

                        compileStoryToScript();
                        renderStoryboard();
                        renderAssets();
                    };
                    reader.readAsDataURL(file);
                    return;
                }

                // For video (synchronous path)
                if (assetType === 'bg') {
                    STATE.storyScenes[sceneIndex].bg = newAssetKey;
                } else {
                    STATE.storyScenes[sceneIndex].broll = newAssetKey;
                }

                saveAssets();
                compileStoryToScript();
                renderStoryboard();
                renderAssets();
            };
            input.click();
        }

        // --- TIMELINE CONTROL HELPERS ---
        function updateSceneDurationMode(sceneIndex, mode) {
            if (!STATE.storyScenes[sceneIndex]) return;
            STATE.storyScenes[sceneIndex].durationMode = mode;
            if (mode === 'auto') STATE.storyScenes[sceneIndex].duration = null;
            renderStoryboard();
        }

        function updateSceneDuration(sceneIndex, value) {
            if (!STATE.storyScenes[sceneIndex]) return;
            const duration = parseFloat(value);
            STATE.storyScenes[sceneIndex].duration = (duration && duration > 0) ? duration : null;
            compileStoryToScript();
        }

        function updateBrollTiming(sceneIndex, field, value) {
            if (!STATE.storyScenes[sceneIndex]) return;
            const val = parseFloat(value) || 0;
            if (field === 'start') {
                STATE.storyScenes[sceneIndex].brollStart = Math.max(0, val);
            } else if (field === 'duration') {
                STATE.storyScenes[sceneIndex].brollDuration = Math.max(0.1, val);
            }
            compileStoryToScript();
        }

        function updateBrollPreset(sceneIndex, preset) {
            if (!STATE.storyScenes[sceneIndex]) return;
            STATE.storyScenes[sceneIndex].brollPreset = preset;

            // Auto-calculate timing based on preset
            // Note: These are defaults. Actual duration will be calculated during playback
            if (preset === 'full') {
                STATE.storyScenes[sceneIndex].brollStart = 0;
                STATE.storyScenes[sceneIndex].brollDuration = 999; // Will use full scene duration
            } else if (preset === 'first-half') {
                STATE.storyScenes[sceneIndex].brollStart = 0;
                STATE.storyScenes[sceneIndex].brollDuration = -0.5; // -0.5 means 50% of scene
            } else if (preset === 'second-half') {
                STATE.storyScenes[sceneIndex].brollStart = -0.5; // -0.5 means start at 50%
                STATE.storyScenes[sceneIndex].brollDuration = -0.5;
            }
            // 'custom' keeps existing values

            renderStoryboard();
            compileStoryToScript();
        }

        function updateSceneBgColor(sceneIndex, color) {
            if (!STATE.storyScenes[sceneIndex]) return;
            STATE.storyScenes[sceneIndex].bgColor = color;
            // Clear bg asset when using color
            STATE.storyScenes[sceneIndex].bg = '';
            compileStoryToScript();
            renderStoryboard();
        }

        function updateSceneLayout(sceneIndex, layoutMode) {
            if (!STATE.storyScenes[sceneIndex]) return;
            STATE.storyScenes[sceneIndex].layoutMode = layoutMode;
            compileStoryToScript();
        }

        function updateTextSize(sceneIndex, textSize) {
            if (!STATE.storyScenes[sceneIndex]) return;
            STATE.storyScenes[sceneIndex].textSize = textSize;
            compileStoryToScript();
        }

        // --- MASTER APP MODE SWITCHER ---
        function setAppMode(mode) {
            STATE.appMode = mode;
            document.getElementById('tabClassic').className = mode === 'classic' ? "flex-1 py-2 text-[10px] font-bold rounded-lg transition-all bg-purple-600 text-white shadow-lg" : "flex-1 py-2 text-[10px] font-bold rounded-lg transition-all text-gray-500 hover:text-white";
            document.getElementById('tabPro').className = mode === 'pro' ? "flex-1 py-2 text-[10px] font-bold rounded-lg transition-all bg-gradient-to-r from-orange-500 to-pink-500 text-white shadow-lg" : "flex-1 py-2 text-[10px] font-bold rounded-lg transition-all text-gray-500 hover:text-white";

            if (mode === 'classic') {
                document.getElementById('animSelectClassic').classList.remove('hidden');
                document.getElementById('animSelectPro').classList.add('hidden');
            } else {
                document.getElementById('animSelectClassic').classList.add('hidden');
                document.getElementById('animSelectPro').classList.remove('hidden');
            }
        }

        // --- PARTICLE ENGINE ---
        class Particle {
            constructor(x, y, color) {
                this.x = x; this.y = y; this.color = color;
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 8 + 2;
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed - 2;
                this.life = 1.0;
                this.decay = Math.random() * 0.03 + 0.02;
                this.size = Math.random() * 4 + 1;
            }
            update() {
                this.x += this.vx; this.y += this.vy;
                this.vy += 0.3;
                this.vx *= 0.95;
                this.life -= this.decay;
            }
            draw(ctx) {
                ctx.globalAlpha = Math.max(0, this.life);
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1.0;
            }
        }

        // --- SPEECH RECOGNITION (MOBILE STRICT MODE FIX) ---
        function toggleDictation() {
            if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
                return alert("Voice dictation is not supported on this browser.");
            }
            const btn = document.getElementById('micBtn');
            const textArea = document.getElementById('scriptInput');

            if (STATE.isRecording) { STATE.recognition.stop(); return; }

            const Recognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            STATE.recognition = new Recognition();
            STATE.recognition.continuous = true;
            // STRICT MODE: Setting interimResults to false completely blocks Android from duplicating guesses.
            STATE.recognition.interimResults = false;
            STATE.recognition.lang = document.getElementById('dictationLang').value || 'en-US';

            STATE.recognition.onstart = () => {
                STATE.isRecording = true;
                btn.innerHTML = '<i data-lucide="mic-off" class="w-3 h-3"></i> Stop';
                btn.className = "text-[10px] px-3 py-1 bg-red-500 text-white border border-red-600 rounded-full hover:bg-red-600 flex items-center gap-1.5 transition shadow-lg shadow-red-500/30";
                textArea.classList.add('recording-pulse');
                lucide.createIcons();
            };

            STATE.recognition.onresult = (event) => {
                let finalStr = '';
                for (let i = event.resultIndex; i < event.results.length; ++i) {
                    if (event.results[i].isFinal) finalStr += event.results[i][0].transcript + ' ';
                }
                if (finalStr) {
                    textArea.value += (textArea.value.endsWith(' ') || textArea.value.length === 0 ? '' : ' ') + finalStr;
                    textArea.scrollTop = textArea.scrollHeight;
                    // If in story mode, update active scene? No, dictation always goes to raw for now
                    // Or we could append to the last scene... but that's complex.
                    // Keep dictation in Raw mode for simplicity.
                }
            };

            STATE.recognition.onend = () => {
                STATE.isRecording = false;
                btn.innerHTML = '<i data-lucide="mic" class="w-3 h-3"></i> Speak';
                btn.className = "text-[10px] px-3 py-1 bg-white/5 text-gray-300 border border-white/10 rounded-full hover:bg-white/10 flex items-center gap-1.5 transition";
                textArea.classList.remove('recording-pulse');
                lucide.createIcons();
            };
            STATE.recognition.start();
        }

        function updateDictationLang() {
            if (STATE.isRecording && STATE.recognition) {
                STATE.recognition.stop();
                setTimeout(() => { toggleDictation(); }, 500);
            }
        }

        // --- VOICE MODE UI ---
        function setVoiceMode(mode) {
            STATE.voiceMode = mode;
            const btnIds = ['btnModeTTS', 'btnModeRec', 'btnModeEleven', 'btnModeUpload', 'btnModeMagic'];
            const ctrlIds = ['ttsControls', 'recControls', 'elevenControls', 'uploadControls', 'magicControls'];

            btnIds.forEach(id => document.getElementById(id).className = "px-3 py-1 text-[10px] font-bold transition tab-inactive whitespace-nowrap");
            ctrlIds.forEach(id => document.getElementById(id).classList.add('hidden'));

            if (mode === 'magic') {
                document.getElementById('btnModeMagic').className = "px-3 py-1 text-[10px] font-bold transition tab-active text-yellow-400 whitespace-nowrap";
                document.getElementById('magicControls').classList.remove('hidden');
            } else if (mode === 'tts') {
                document.getElementById('btnModeTTS').className = "px-3 py-1 text-[10px] font-bold transition tab-active whitespace-nowrap";
                document.getElementById('ttsControls').classList.remove('hidden');
            } else if (mode === 'rec') {
                document.getElementById('btnModeRec').className = "px-3 py-1 text-[10px] font-bold transition tab-active whitespace-nowrap";
                document.getElementById('recControls').classList.remove('hidden');
                if (STATE.recMode === 'scene') generateSceneList();
            } else if (mode === 'eleven') {
                document.getElementById('btnModeEleven').className = "px-3 py-1 text-[10px] font-bold transition tab-active text-purple-400 whitespace-nowrap";
                document.getElementById('elevenControls').classList.remove('hidden');
            } else if (mode === 'upload') {
                document.getElementById('btnModeUpload').className = "px-3 py-1 text-[10px] font-bold transition tab-active whitespace-nowrap";
                document.getElementById('uploadControls').classList.remove('hidden');
            }
        }

        // --- MAGIC CLOUD TTS ---
        async function generateMagicAudio() {
            // Ensure we use the latest script (compiled from story if active)
            if (STATE.editorMode === 'story') compileStoryToScript();

            const text = document.getElementById('scriptInput').value;
            // Clean syntax elements so they are ignored by TTS engine (now filtering [bg=] too)
            const cleanScript = text.replace(/\[bg=.*?\]/ig, '').replace(/\{.*?\}/g, '').replace(/\[.*?\]/g, '').replace(/\(.*?\)/g, '').replace(/\*/g, '').replace(/_/g, '').replace(/[\p{Emoji_Presentation}\p{Extended_Pictographic}]/gu, '');

            const words = cleanScript.split(/\s+/);
            const chunks = [];
            let cur = '';
            for (let w of words) {
                if (cur.length + w.length > 150) { chunks.push(cur); cur = ''; }
                cur += w + ' ';
            }
            if (cur) chunks.push(cur);

            if (chunks.length === 0 || !chunks[0].trim()) return alert("Enter script first!");

            const lang = document.getElementById('magicLang').value;
            const btn = document.getElementById('magicGenBtn');
            btn.innerHTML = '<div class="w-3 h-3 border-2 border-black border-t-transparent rounded-full animate-spin"></div> CASTING...';
            btn.disabled = true;

            try {
                const blobs = [];
                for (let chunk of chunks) {
                    const url = `https://translate.google.com/translate_tts?ie=UTF-8&client=tw-ob&tl=${lang}&q=${encodeURIComponent(chunk.trim())}`;
                    const proxies = [
                        `https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`,
                        url,
                        `https://api.codetabs.com/v1/proxy?quest=${encodeURIComponent(url)}`
                    ];

                    let success = false;
                    for (let proxy of proxies) {
                        try {
                            const res = await fetch(proxy);
                            if (res.ok) { blobs.push(await res.blob()); success = true; break; }
                        } catch (e) { }
                    }
                    if (!success) throw new Error("Proxies blocked.");
                }

                STATE.continuousBlob = new Blob(blobs, { type: 'audio/mpeg' });
                const audio = document.getElementById('magicAudioPreview');
                audio.src = URL.createObjectURL(STATE.continuousBlob);
                document.getElementById('magicPlayerContainer').classList.remove('hidden');

            } catch (e) {
                alert("Magic failed. The free cloud servers are busy. Please use 'ü§ñ System', 'üéôÔ∏è Me' or 'üìÅ Upload' tabs instead.");
            }

            btn.innerHTML = '‚ú® GENERATE MAGIC AUDIO';
            btn.disabled = false;
            lucide.createIcons();
        }

        // --- UPLOAD LOGIC ---
        function handleAudioUpload(input) {
            const file = input.files[0];
            if (!file) return;
            STATE.continuousBlob = file;
            document.getElementById('uploadAudioPreview').src = URL.createObjectURL(file);
            document.getElementById('uploadAudioPlayerContainer').classList.remove('hidden');
        }
        function deleteUploadedAudio() {
            STATE.continuousBlob = null;
            document.getElementById('uploadAudioInput').value = '';
            document.getElementById('uploadAudioPreview').src = '';
            document.getElementById('uploadAudioPlayerContainer').classList.add('hidden');
        }

        // --- ELEVENLABS LOGIC ---
        function saveElevenKey() {
            const key = document.getElementById('elevenApiKey').value.trim();
            if (key) { localStorage.setItem('eleven_key', key); STATE.elevenKey = key; alert("API Key Saved!"); }
        }
        async function fetchElevenVoices() {
            const inputKey = document.getElementById('elevenApiKey').value.trim();
            if (!STATE.elevenKey && inputKey) STATE.elevenKey = inputKey;
            if (!STATE.elevenKey) return alert("Please Paste & Save API Key first.");
            const btn = document.querySelector('#elevenControls button[title="Refresh Voices"]');
            btn.innerHTML = '...';
            try {
                const res = await fetch('https://api.elevenlabs.io/v1/voices', { headers: { 'xi-api-key': STATE.elevenKey.trim() } });
                if (!res.ok) throw new Error("Invalid API Key");
                const data = await res.json();
                const sel = document.getElementById('elevenVoiceSelect');
                sel.innerHTML = '<option value="">Select Voice...</option>';
                const cloned = data.voices.filter(v => v.category === 'cloned');
                const premade = data.voices.filter(v => v.category !== 'cloned');
                if (cloned.length > 0) {
                    const grp = document.createElement('optgroup'); grp.label = "Your Cloned Voices";
                    cloned.forEach(v => { grp.innerHTML += `<option value="${v.voice_id}">üë§ ${v.name}</option>`; });
                    sel.appendChild(grp);
                }
                const grp2 = document.createElement('optgroup'); grp2.label = "Premade Voices";
                premade.forEach(v => { grp2.innerHTML += `<option value="${v.voice_id}">${v.name}</option>`; });
                sel.appendChild(grp2);
            } catch (e) { alert(e.message); }
            btn.innerHTML = '<i data-lucide="refresh-cw" class="w-3 h-3"></i>';
            lucide.createIcons();
        }
        async function createElevenClone() {
            const name = document.getElementById('cloneName').value;
            const fileInput = document.getElementById('cloneFile');
            if (!name || !fileInput.files[0]) return alert("Name and Audio file required!");

            const inputKey = document.getElementById('elevenApiKey').value.trim();
            if (!STATE.elevenKey && inputKey) STATE.elevenKey = inputKey;
            if (!STATE.elevenKey) return alert("API Key required!");

            const btn = document.querySelector('#elevenControls details button');
            const originalText = btn.innerText;
            btn.innerText = "Uploading...";
            btn.disabled = true;

            const formData = new FormData();
            formData.append('name', name);
            formData.append('files', fileInput.files[0]);
            formData.append('description', 'Viral Studio Clone');

            try {
                const res = await fetch('https://api.elevenlabs.io/v1/voices/add', {
                    method: 'POST',
                    headers: { 'xi-api-key': STATE.elevenKey.trim() },
                    body: formData
                });

                if (res.status === 401) throw new Error("Invalid API Key");
                if (!res.ok) throw new Error(await res.text());

                alert("Voice Cloned Successfully! Refreshing list...");
                fetchElevenVoices();
                document.getElementById('cloneName').value = '';
                fileInput.value = '';
            } catch (e) { alert("Error cloning: " + e.message); }
            btn.innerText = originalText;
            btn.disabled = false;
        }
        async function generateElevenAudio() {
            if (STATE.editorMode === 'story') compileStoryToScript();

            const voiceId = document.getElementById('elevenVoiceSelect').value;
            const text = document.getElementById('scriptInput').value.replace(/\[bg=.*?\]/ig, '').replace(/\{.*?\}/g, '').replace(/\[.*?\]/g, '').replace(/\(.*?\)/g, '').replace(/\*/g, '').replace(/_/g, '');
            if (!voiceId || !text) return alert("Select voice and enter text!");
            const btn = document.getElementById('elGenBtn'); btn.innerHTML = 'Generating...'; btn.disabled = true;
            try {
                const res = await fetch(`https://api.elevenlabs.io/v1/text-to-speech/${voiceId}`, {
                    method: 'POST', headers: { 'xi-api-key': STATE.elevenKey.trim(), 'Content-Type': 'application/json' },
                    body: JSON.stringify({ text, model_id: "eleven_multilingual_v2", voice_settings: { stability: 0.5, similarity_boost: 0.75 } })
                });
                if (!res.ok) throw new Error("API Error");
                const blob = await res.blob();
                STATE.continuousBlob = blob;
                document.getElementById('elevenAudioPreview').src = URL.createObjectURL(blob);
                document.getElementById('elevenPlayerContainer').classList.remove('hidden');
            } catch (e) { alert("Failed: " + e.message); }
            btn.innerHTML = '<i data-lucide="sparkles" class="w-3 h-3"></i> GENERATE AUDIO'; btn.disabled = false; lucide.createIcons();
        }

        // --- RECORDER SUB-MODES ---
        function setRecSubMode(mode) {
            STATE.recMode = mode;
            const sBtn = document.getElementById('subModeScene'); const cBtn = document.getElementById('subModeCont');
            const sUI = document.getElementById('sceneUI'); const cUI = document.getElementById('continuousUI');
            if (mode === 'scene') {
                sBtn.className = "flex-1 py-1 text-[9px] rounded-md transition sub-tab-active"; cBtn.className = "flex-1 py-1 text-[9px] rounded-md transition sub-tab-inactive";
                sUI.classList.remove('hidden'); cUI.classList.add('hidden'); generateSceneList();
            } else {
                sBtn.className = "flex-1 py-1 text-[9px] rounded-md transition sub-tab-inactive"; cBtn.className = "flex-1 py-1 text-[9px] rounded-md transition sub-tab-active";
                sUI.classList.add('hidden'); cUI.classList.remove('hidden');
            }
        }

        function generateSceneList() {
            // Scene Recorder uses raw script (less likely to be used with visual builder, but syncs anyway)
            if (STATE.editorMode === 'story') compileStoryToScript();

            const text = document.getElementById('scriptInput').value;
            const lines = text.split('\n').filter(l => l.trim() !== '');
            const container = document.getElementById('sceneListContainer'); container.innerHTML = '';
            lines.forEach((line, index) => {
                const hasAudio = !!STATE.sceneAudios[index];
                const div = document.createElement('div'); div.className = 'scene-item';
                div.innerHTML = `<span class="scene-text" title="${line}">${index + 1}. ${line}</span>
                    <div class="flex gap-2"><button onclick="recordScene(${index}, this)" class="rec-btn-small ${STATE.recordingIndex === index ? 'rec-active' : ''}"><i data-lucide="${STATE.recordingIndex === index ? 'square' : 'mic'}" class="w-3 h-3 text-white"></i></button>
                    ${hasAudio ? `<button onclick="playSceneAudio(${index})" class="rec-btn-small play-btn-small"><i data-lucide="play" class="w-3 h-3"></i></button><button onclick="deleteSceneAudio(${index})" class="rec-btn-small del-btn-small"><i data-lucide="trash-2" class="w-3 h-3"></i></button>` : ''}</div>`;
                container.appendChild(div);
            });
            lucide.createIcons();
        }

        async function recordScene(index, btn) {
            if (STATE.recordingIndex === index) { STATE.activeRecorder.stop(); STATE.recordingIndex = null; STATE.activeRecorder = null; generateSceneList(); return; }
            if (STATE.recordingIndex !== null) return alert("Stop current recording first!");
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                const mediaRecorder = new MediaRecorder(stream); const chunks = [];
                mediaRecorder.ondataavailable = e => chunks.push(e.data);
                mediaRecorder.onstop = () => { STATE.sceneAudios[index] = new Blob(chunks, { type: 'audio/mp3' }); generateSceneList(); };
                mediaRecorder.start(); STATE.activeRecorder = mediaRecorder; STATE.recordingIndex = index; generateSceneList();
            } catch (e) { alert("Mic access required!"); }
        }
        function playSceneAudio(index) { if (STATE.sceneAudios[index]) { new Audio(URL.createObjectURL(STATE.sceneAudios[index])).play(); } }
        function deleteSceneAudio(index) { if (confirm("Delete audio?")) { delete STATE.sceneAudios[index]; generateSceneList(); } }

        async function toggleContinuousRecord() {
            const btn = document.getElementById('contRecBtn'); const pauseBtn = document.getElementById('contPauseBtn');
            const prompter = document.getElementById('prompterContainer'); const prompterText = document.getElementById('prompterText');

            if (STATE.isContRecording) {
                STATE.activeRecorder.stop(); STATE.isContRecording = false; STATE.activeRecorder = null;
                btn.innerHTML = '<i data-lucide="mic" class="w-4 h-4"></i> Re-Record'; btn.className = "w-full py-3 rounded-xl bg-white/5 border border-white/10 text-white font-bold flex items-center justify-center gap-2 hover:bg-white/10 transition";
                pauseBtn.classList.add('hidden'); prompter.classList.add('hidden'); lucide.createIcons(); return;
            }

            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                const mediaRecorder = new MediaRecorder(stream); const chunks = [];
                mediaRecorder.ondataavailable = e => chunks.push(e.data);
                mediaRecorder.onstop = () => {
                    STATE.continuousBlob = new Blob(chunks, { type: 'audio/mp3' });
                    document.getElementById('contAudioEl').src = URL.createObjectURL(STATE.continuousBlob);
                    document.getElementById('contAudioPlayer').classList.remove('hidden');
                };
                mediaRecorder.start(); STATE.activeRecorder = mediaRecorder; STATE.isContRecording = true; STATE.isContPaused = false;
                btn.innerHTML = '<div class="w-3 h-3 bg-white rounded animate-pulse"></div> Stop'; btn.className = "flex-1 py-3 rounded-xl bg-red-600 text-white border border-red-500 font-bold flex items-center justify-center gap-2 recording-pulse";
                pauseBtn.classList.remove('hidden'); pauseBtn.innerHTML = '<i data-lucide="pause" class="w-4 h-4"></i>';
                prompter.classList.remove('hidden'); prompterText.innerText = document.getElementById('scriptInput').value.replace(/\[bg=.*?\]/ig, '').replace(/\{.*?\}/g, '').replace(/\[.*?\]/g, '').replace(/\(.*?\)/g, '').replace(/\*/g, '').replace(/_/g, '');
                lucide.createIcons();
            } catch (e) { alert("Mic required!"); }
        }
        function togglePauseCont() {
            const btn = document.getElementById('contPauseBtn');
            if (!STATE.activeRecorder) return;
            if (STATE.activeRecorder.state === 'recording') { STATE.activeRecorder.pause(); STATE.isContPaused = true; btn.innerHTML = '<i data-lucide="play" class="w-4 h-4"></i>'; btn.className = "w-1/3 py-3 rounded-xl bg-green-600/20 text-green-500 border border-green-600/50 hover:bg-green-600 hover:text-white transition font-bold flex items-center justify-center gap-2"; }
            else if (STATE.activeRecorder.state === 'paused') { STATE.activeRecorder.resume(); STATE.isContPaused = false; btn.innerHTML = '<i data-lucide="pause" class="w-4 h-4"></i>'; btn.className = "w-1/3 py-3 rounded-xl bg-yellow-600/20 text-yellow-500 border border-yellow-600/50 hover:bg-yellow-600 hover:text-white transition font-bold flex items-center justify-center gap-2"; }
            lucide.createIcons();
        }
        function deleteContinuousAudio() { if (confirm("Delete this recording?")) { STATE.continuousBlob = null; document.getElementById('contAudioPlayer').classList.add('hidden'); document.getElementById('contAudioEl').src = ""; } }

        // --- ADVANCED SCRIPT PARSER ---
        function parseScript(text) {
            const scenes = text.split('\n'); const layout = [];

            // Get current scene properties if in storyboard mode
            let currentSceneIndex = 0;

            ctx.font = `900 ${STATE.format.fontSize * SCALE}px '${document.getElementById('fontSelect').value}'`;

            scenes.forEach((sceneText, sceneIdx) => {
                // Skip empty scenes
                if (!sceneText || !sceneText.trim()) return;

                // Get scene-specific properties from storyboard
                const scene = STATE.storyScenes[sceneIdx] || {};
                const textSize = scene.textSize || scene._textSize || 'normal';
                const layoutMode = scene.layoutMode || scene._layoutMode || 'text-over-media';

                // Calculate text size multiplier
                let sizeMultiplier = 1;
                if (textSize === 'small') sizeMultiplier = 0.5;
                else if (textSize === 'large') sizeMultiplier = 1.5;
                else if (textSize === 'huge') sizeMultiplier = 2.0;

                // Update font size for this scene
                const baseFontSize = STATE.format.fontSize * SCALE;
                ctx.font = `900 ${baseFontSize * sizeMultiplier}px '${document.getElementById('fontSelect').value}'`;

                const rawWords = sceneText.trim().split(/\s+/);
                const lines = []; let currentLine = []; let currentW = 0; let currentLineHasMedia = false;

                let lineAlignX = 'center'; let lineAlignY = 'center';
                let currentBgChange = null; // CRITICAL: Define at start of each scene

                rawWords.forEach(token => {
                    // IMPROVED: Skip empty or whitespace-only tokens to prevent duplicates
                    if (!token || !token.trim()) return;
                    let text = token; let imgKey = null; let annotation = null; let isSilent = false;
                    let isPinned = false; let customAnim = null; let isHighlight = false; let isHuge = false; let isGap = false;
                    let isCenterBroll = false; let isWipe = false; let bgChange = null;

                    const bgMatch = text.match(/\[bg=(.*?)\]/i);
                    if (bgMatch) {
                        bgChange = bgMatch[1].trim();
                        currentBgChange = bgChange; // Update persistent background
                        text = text.replace(bgMatch[0], '');
                    }

                    if (text.toLowerCase() === '[top]') { lineAlignY = 'top'; return; }
                    if (text.toLowerCase() === '[bottom]') { lineAlignY = 'bottom'; return; }
                    if (text.toLowerCase() === '[left]') { lineAlignX = 'left'; return; }
                    if (text.toLowerCase() === '[right]') { lineAlignX = 'right'; return; }

                    const animMatch = text.match(/\{([a-zA-Z]+)\}/);
                    if (animMatch) {
                        if (animMatch[1].toLowerCase() === 'wipe') isWipe = true;
                        else customAnim = animMatch[1].toLowerCase();
                        text = text.replace(animMatch[0], '');
                    }

                    const imgMatch = text.match(/^([^\[\(\{]*?)[\(\[\{](.*?)[\)\]\}]$/);
                    if (imgMatch) {
                        let content = imgMatch[2].toLowerCase().trim();
                        if (content.startsWith('+')) { isPinned = true; content = content.substring(1); }
                        else if (content.startsWith('=')) { isCenterBroll = true; content = content.substring(1); }

                        if (content === 'circle' || content === 'arrow') {
                            text = imgMatch[1]; annotation = content;
                        } else {
                            text = imgMatch[1];
                            imgKey = (!STATE.assets[content] && STATE.assets[token.toLowerCase().replace(/[\(\[\{].*?[\)\]\}]/g, '')]) ? null : content;
                        }
                    }
                    if (!text && (imgKey || bgChange)) isSilent = true;

                    if (text.includes('**')) {
                        isHuge = true; isHighlight = true;
                        text = text.replace(/\*\*/g, '');
                    } else if (text.includes('*')) {
                        isHighlight = true;
                        text = text.replace(/\*/g, '');
                    }

                    if (text === '_') { isGap = true; isSilent = true; text = ''; }
                    if (isCenterBroll) { isGap = true; isSilent = true; text = ''; }

                    let cleanText = text; // FIXED: Changed const to let
                    let width = 0;

                    if (cleanText) {
                        width += ctx.measureText(cleanText + " ").width / SCALE;
                        if (isHuge) width *= 1.4;
                        else if (isHighlight) width *= 1.15;
                    }

                    let imgSize = 0; let hasMedia = false;
                    if (imgKey && STATE.assets[imgKey]) {
                        if (!isPinned && !isCenterBroll) {
                            // Hide inline media if layout mode is 'text-only'
                            if (layoutMode !== 'text-only') {
                                imgSize = STATE.format.fontSize * 3 * sizeMultiplier;
                                width += imgSize + 10;
                                hasMedia = true;
                            }
                        }
                    }

                    // Hide text if layout mode is 'media-only'
                    const shouldShowText = layoutMode !== 'media-only';
                    if (!shouldShowText && cleanText) {
                        // Create a gap/silent word to maintain timing
                        cleanText = '';
                        isSilent = true;
                        isGap = true;
                    }

                    if (currentW + width > (STATE.format.w - 60)) {
                        lines.push({ words: currentLine, hasMedia: currentLineHasMedia, alignX: lineAlignX, alignY: lineAlignY });
                        currentLine = []; currentW = 0; currentLineHasMedia = false;
                    }

                    currentLine.push({
                        cleanText, imgKey, annotation, width, imgSize, hasMedia,
                        isHighlight, isHuge, isSilent, isGap, isWipe, isPinned, isCenterBroll,
                        bgChange: currentBgChange, customAnim,
                        layoutMode, sizeMultiplier  // Store for rendering
                    });

                    currentW += width; if (hasMedia) currentLineHasMedia = true;
                });

                if (currentLine.length > 0) lines.push({ words: currentLine, hasMedia: currentLineHasMedia, alignX: lineAlignX, alignY: lineAlignY });

                const baseH = STATE.format.fontSize; let totalH = 0;
                lines.forEach(l => { l.height = l.hasMedia ? baseH * 3.5 : baseH * 1.5; totalH += l.height; });

                let startY;
                if (lineAlignY === 'top') startY = STATE.format.h * 0.2;
                else if (lineAlignY === 'bottom') startY = STATE.format.h * 0.8 - totalH;
                else startY = (STATE.format.h - totalH) / 2;

                lines.forEach(line => {
                    let startX;
                    const lineW = line.words.reduce((a, b) => a + b.width, 0);
                    if (line.alignX === 'left') startX = 40;
                    else if (line.alignX === 'right') startX = STATE.format.w - lineW - 40;
                    else startX = (STATE.format.w - lineW) / 2;

                    const centerY = startY + (line.height / 2);
                    line.words.forEach((w, i) => { layout.push({ ...w, x: startX, y: centerY, isNewLine: i === 0 && line === lines[0], sceneIndex: sceneIdx }); startX += w.width; });
                    startY += line.height;
                });
                layout.push({ isBreak: true, sceneIndex: sceneIdx });
            });
            return layout;
        }

        // --- PRO MODE PHRASE BUILDER ---
        function buildProPhrases(timeline) {
            STATE.proPhrases = [];
            let curPhrase = { startTime: 0, endTime: 0, words: [] };

            timeline.forEach((w, i) => {
                if (w.type === 'break') return;
                if (curPhrase.words.length === 0) curPhrase.startTime = w.time;
                curPhrase.words.push(w);
                curPhrase.endTime = w.endTime;

                if (curPhrase.words.length >= 4 || w.item.cleanText.match(/[.!?]$/) || i === timeline.length - 1) {
                    STATE.proPhrases.push({ ...curPhrase });
                    curPhrase = { startTime: 0, endTime: 0, words: [] };
                }
            });
        }

        // --- PREVIEW / PLAYBACK ---
        function togglePreview() { STATE.isPlaying ? stopPreview() : startPreview(); }

        async function startPreview() {
            // SYNC CHECK: If in Story Mode, force update of script
            if (STATE.editorMode === 'story') compileStoryToScript();

            stopPreview();
            const btn = document.getElementById('playBtn'); btn.innerHTML = '<div class="w-3 h-3 border-2 border-black border-t-transparent rounded-full animate-spin"></div> Starting...';
            document.body.style.cursor = 'wait';
            await new Promise(r => setTimeout(r, 100));
            await document.fonts.ready;

            STATE.baseBgType = STATE.bgType;
            STATE.baseBgValue = STATE.bgValue;
            STATE.currentDynamicBg = null;

            STATE.objects = []; STATE.particles = []; STATE.screenShake = 0; STATE.globalZoom = 0;
            STATE.wordIndex = 0; STATE.playbackProgress = 0; STATE.proAudioTime = 0;
            STATE.activePins = []; STATE.activeCenterBrolls = [];

            const text = document.getElementById('scriptInput').value; STATE.layout = parseScript(text);
            if (STATE.layout.length === 0) { resetUI(); return; }

            STATE.isPlaying = true;

            if (STATE.voiceMode === 'rec' && STATE.recMode === 'scene') {
                playSceneSequence(0);
            } else if (STATE.voiceMode === 'eleven' || STATE.voiceMode === 'magic' || (STATE.voiceMode === 'rec' && STATE.recMode === 'continuous') || STATE.voiceMode === 'upload') {
                playContinuous();
            } else {
                playTTSSequence(text);
            }

            document.body.style.cursor = 'default';
            btn.innerHTML = '<i data-lucide="square" class="w-3 h-3 fill-current"></i> STOP'; lucide.createIcons();
        }

        function finishPlayback() {
            if (STATE.isFinishing) return;
            STATE.isFinishing = true;
            STATE.playbackProgress = 100;

            setTimeout(() => {
                if (STATE.isFinishing) {
                    STATE.isFinishing = false;
                    stopPreview();
                }
            }, 2500);
        }

        async function playContinuous() {
            if (!STATE.continuousBlob) {
                let msg = "No audio found!";
                if (STATE.voiceMode === 'eleven') msg = "Generate ElevenLabs Audio first!";
                else if (STATE.voiceMode === 'rec') msg = "Record Single Take first!";
                else if (STATE.voiceMode === 'upload') msg = "Upload an audio file first!";

                alert(msg); stopPreview(); return;
            }

            const audio = new Audio(URL.createObjectURL(STATE.continuousBlob));
            STATE.currentAudio = audio;

            audio.onloadedmetadata = () => {
                if (audio.duration === Infinity || isNaN(audio.duration)) {
                    audio.currentTime = 1e10;
                    audio.ontimeupdate = () => {
                        audio.ontimeupdate = null;
                        const durSec = audio.duration;
                        audio.currentTime = 0;
                        setTimeout(() => startSyncPlayback(durSec), 50);
                    };
                } else { startSyncPlayback(audio.duration); }
            };

            function startSyncPlayback(durationSec) {
                const durationMs = durationSec * 1000;
                const allItems = STATE.layout;
                let totalWeight = 0;

                // IMPROVED: Use word count instead of character length for better sync
                allItems.forEach(i => {
                    if (!i.isBreak) {
                        const wordCount = i.cleanText ? i.cleanText.split(/\s+/).filter(w => w.length > 0).length : 0;
                        const baseWeight = wordCount * 8 + 5; // 8 units per word + 5 base pause
                        totalWeight += baseWeight;
                    }
                });
                const timePerWeight = durationMs / (totalWeight || 1);

                let timeline = []; let currentTime = 0;
                allItems.forEach(item => {
                    if (item.isBreak) { timeline.push({ type: 'break', time: currentTime }); }
                    else {
                        // IMPROVED: Calculate duration based on word count
                        const wordCount = item.cleanText ? item.cleanText.split(/\s+/).filter(w => w.length > 0).length : 0;
                        const baseWeight = wordCount * 8 + 5;
                        let dur = baseWeight * timePerWeight;
                        timeline.push({ type: 'word', item: item, time: currentTime, endTime: currentTime + dur });
                        currentTime += dur;
                    }
                });

                buildProPhrases(timeline);
                audio.play(); let currentIndex = 0;

                function syncLoop() {
                    if (!STATE.isPlaying || !STATE.currentAudio) return;
                    const audioTime = audio.currentTime * 1000;
                    STATE.playbackProgress = (audio.currentTime / audio.duration) * 100;

                    if (STATE.appMode === 'classic') {
                        while (currentIndex < timeline.length && audioTime >= timeline[currentIndex].time) {
                            const event = timeline[currentIndex];
                            if (event.type === 'break') { STATE.objects = []; STATE.activePins = []; STATE.activeCenterBrolls = []; }
                            else {
                                if (event.item && event.item.bgChange) {
                                    if (event.item.bgChange === 'reset') STATE.currentDynamicBg = null;
                                    else STATE.currentDynamicBg = event.item.bgChange;
                                }
                                spawnItem(event.item);
                                if (event.item.isCenterBroll && event.item.imgKey) STATE.activeCenterBrolls.push({ key: event.item.imgKey, spawn: performance.now() });
                            }
                            currentIndex++;
                        }
                    } else {
                        STATE.proAudioTime = audioTime;
                        while (currentIndex < timeline.length && audioTime >= timeline[currentIndex].time) {
                            const event = timeline[currentIndex];
                            if (event.type === 'break') { STATE.activePins = []; STATE.activeCenterBrolls = []; }
                            else {
                                if (event.item && event.item.bgChange) {
                                    if (event.item.bgChange === 'reset') STATE.currentDynamicBg = null;
                                    else STATE.currentDynamicBg = event.item.bgChange;
                                }
                                if (event.item.isPinned && event.item.imgKey && !STATE.activePins.includes(event.item.imgKey)) STATE.activePins.push(event.item.imgKey);
                                if (event.item.isCenterBroll && event.item.imgKey && !STATE.activeCenterBrolls.find(b => b.key === event.item.imgKey)) STATE.activeCenterBrolls.push({ key: event.item.imgKey, spawn: performance.now() });
                            }
                            currentIndex++;
                        }
                    }

                    if (currentIndex < timeline.length || STATE.appMode === 'pro') STATE.animTimer = requestAnimationFrame(syncLoop);
                }
                STATE.animTimer = requestAnimationFrame(syncLoop);
                audio.onended = finishPlayback;
            }
            audio.load();
        }

        async function playSceneSequence(sceneIdx) {
            if (!STATE.isPlaying) return;
            const sceneItems = STATE.layout.filter(item => item.sceneIndex === sceneIdx && !item.isBreak);
            if (sceneItems.length === 0 && sceneIdx < STATE.layout[STATE.layout.length - 1].sceneIndex) { playSceneSequence(sceneIdx + 1); return; }
            if (sceneItems.length === 0) { finishPlayback(); return; }

            const audioBlob = STATE.sceneAudios[sceneIdx];
            const totalScenes = STATE.layout.length > 0 ? STATE.layout[STATE.layout.length - 1].sceneIndex + 1 : 1;

            if (audioBlob) {
                const audio = new Audio(URL.createObjectURL(audioBlob)); STATE.currentAudio = audio;
                let exactDurationMs = 0;
                try {
                    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                    const arrayBuffer = await audioBlob.arrayBuffer();
                    const decodedData = await audioCtx.decodeAudioData(arrayBuffer);
                    exactDurationMs = decodedData.duration * 1000;
                } catch (e) {
                    audio.currentTime = 1e10;
                    await new Promise(r => { audio.ontimeupdate = () => { exactDurationMs = audio.duration * 1000; audio.ontimeupdate = null; r(); }; });
                    audio.currentTime = 0;
                }

                let totalWeight = 0;
                // IMPROVED: Use word count for scene timing
                sceneItems.forEach(i => {
                    const wordCount = i.cleanText ? i.cleanText.split(/\s+/).filter(w => w.length > 0).length : 0;
                    totalWeight += wordCount * 8 + 5;
                });
                const timePerWeight = exactDurationMs / (totalWeight || 1);

                let timeline = []; let currentTime = 0;
                sceneItems.forEach(item => {
                    const wordCount = item.cleanText ? item.cleanText.split(/\s+/).filter(w => w.length > 0).length : 0;
                    let dur = (wordCount * 8 + 5) * timePerWeight;
                    timeline.push({ type: 'word', item: item, time: currentTime, endTime: currentTime + dur });
                    currentTime += dur;
                });

                buildProPhrases(timeline);
                audio.play(); let currentIndex = 0;

                function syncLoop() {
                    if (!STATE.isPlaying || !STATE.currentAudio) return;
                    const audioTime = audio.currentTime * 1000;
                    STATE.playbackProgress = ((sceneIdx + (audio.currentTime / audio.duration)) / totalScenes) * 100;

                    if (STATE.appMode === 'classic') {
                        while (currentIndex < timeline.length && audioTime >= timeline[currentIndex].time) {
                            if (timeline[currentIndex].item && timeline[currentIndex].item.bgChange) {
                                if (timeline[currentIndex].item.bgChange === 'reset') STATE.currentDynamicBg = null;
                                else STATE.currentDynamicBg = timeline[currentIndex].item.bgChange;
                            }
                            spawnItem(timeline[currentIndex].item);
                            if (timeline[currentIndex].item.isCenterBroll && timeline[currentIndex].item.imgKey) STATE.activeCenterBrolls.push({ key: timeline[currentIndex].item.imgKey, spawn: performance.now() });
                            currentIndex++;
                        }
                    } else {
                        STATE.proAudioTime = audioTime;
                        while (currentIndex < timeline.length && audioTime >= timeline[currentIndex].time) {
                            const event = timeline[currentIndex];
                            if (event.item && event.item.bgChange) {
                                if (event.item.bgChange === 'reset') STATE.currentDynamicBg = null;
                                else STATE.currentDynamicBg = event.item.bgChange;
                            }
                            if (event.item.isPinned && event.item.imgKey && !STATE.activePins.includes(event.item.imgKey)) STATE.activePins.push(event.item.imgKey);
                            if (event.item.isCenterBroll && event.item.imgKey && !STATE.activeCenterBrolls.find(b => b.key === event.item.imgKey)) STATE.activeCenterBrolls.push({ key: event.item.imgKey, spawn: performance.now() });
                            currentIndex++;
                        }
                    }
                    if (currentIndex < timeline.length || STATE.appMode === 'pro') STATE.animTimer = requestAnimationFrame(syncLoop);
                }
                STATE.animTimer = requestAnimationFrame(syncLoop);
                audio.onended = () => { if (STATE.animTimer) cancelAnimationFrame(STATE.animTimer); STATE.objects = []; STATE.activePins = []; STATE.activeCenterBrolls = []; playSceneSequence(sceneIdx + 1); };

            } else {
                let idx = 0;
                STATE.animTimer = setInterval(() => {
                    STATE.playbackProgress = ((sceneIdx + (idx / sceneItems.length)) / totalScenes) * 100;
                    if (idx < sceneItems.length) {
                        if (sceneItems[idx] && sceneItems[idx].bgChange) {
                            if (sceneItems[idx].bgChange === 'reset') STATE.currentDynamicBg = null;
                            else STATE.currentDynamicBg = sceneItems[idx].bgChange;
                        }
                        spawnItem(sceneItems[idx]);
                        if (sceneItems[idx].isPinned && sceneItems[idx].imgKey && !STATE.activePins.includes(sceneItems[idx].imgKey)) STATE.activePins.push(sceneItems[idx].imgKey);
                        if (sceneItems[idx].isCenterBroll && sceneItems[idx].imgKey) STATE.activeCenterBrolls.push({ key: sceneItems[idx].imgKey, spawn: performance.now() });
                        idx++;
                    }
                    else { clearInterval(STATE.animTimer); setTimeout(() => { STATE.objects = []; STATE.activePins = []; STATE.activeCenterBrolls = []; playSceneSequence(sceneIdx + 1); }, 1000); }
                }, 400);
            }
        }

        // Global utterance storage to prevent Garbage Collection (Fixes 'interrupted' error)
        window.ttsUtterances = [];

        function playTTSSequence(text) {
            let speechText = text.replace(/\[bg=.*?\]/ig, '').replace(/\{.*?\}/g, '').replace(/\[.*?\]/g, '').replace(/\(.*?\)/g, '').replace(/\*/g, '').replace(/_/g, '').replace(/[\p{Emoji_Presentation}\p{Extended_Pictographic}]/gu, '');
            const u = new SpeechSynthesisUtterance(speechText);

            // Store to prevent GC
            window.ttsUtterances.push(u);
            u.onend = () => {
                const idx = window.ttsUtterances.indexOf(u);
                if (idx > -1) window.ttsUtterances.splice(idx, 1);
            };

            const vName = document.getElementById('voiceSelect').value;
            const voiceInfo = window.speechSynthesis.getVoices().find(v => v.name === vName);
            if (voiceInfo) u.voice = voiceInfo;
            u.rate = parseFloat(document.getElementById('speedRange').value);

            let boundaryFired = false;
            const startFallback = () => {
                if (boundaryFired || !STATE.isPlaying) return;
                STATE.isFallbackPlaying = true;
                const durationMs = (speechText.length * 75) / u.rate;

                // IMPROVED: Use word count for TTS timing (same as recorded voice)
                let totalWeight = 0;
                STATE.layout.forEach(i => {
                    if (!i.isBreak) {
                        const wordCount = i.cleanText ? i.cleanText.split(/\s+/).filter(w => w.length > 0).length : 0;
                        totalWeight += wordCount * 8 + 5;
                    }
                });
                const timePerWeight = durationMs / (totalWeight || 1);

                let timeline = []; let currentTime = 0;
                STATE.layout.forEach(item => {
                    if (item.isBreak) { timeline.push({ type: 'break', time: currentTime }); }
                    else {
                        const wordCount = item.cleanText ? item.cleanText.split(/\s+/).filter(w => w.length > 0).length : 0;
                        let dur = (wordCount * 8 + 5) * timePerWeight;
                        timeline.push({ type: 'word', item: item, time: currentTime, endTime: currentTime + dur });
                        currentTime += dur;
                    }
                });

                buildProPhrases(timeline);
                const startTime = Date.now(); let currentIndex = 0;

                function syncLoop() {
                    if (!STATE.isPlaying) return;
                    const elapsed = Date.now() - startTime;
                    STATE.playbackProgress = (currentIndex / timeline.length) * 100;

                    if (STATE.appMode === 'classic') {
                        while (currentIndex < timeline.length && elapsed >= timeline[currentIndex].time) {
                            const event = timeline[currentIndex];
                            if (event.type === 'break') { STATE.objects = []; STATE.activePins = []; STATE.activeCenterBrolls = []; }
                            else {
                                if (event.item && event.item.bgChange) {
                                    if (event.item.bgChange === 'reset') STATE.currentDynamicBg = null;
                                    else STATE.currentDynamicBg = event.item.bgChange;
                                }
                                spawnItem(event.item);
                                if (event.item.isCenterBroll && event.item.imgKey) STATE.activeCenterBrolls.push({ key: event.item.imgKey, spawn: performance.now() });
                            }
                            currentIndex++;
                        }
                    } else {
                        STATE.proAudioTime = elapsed;
                        while (currentIndex < timeline.length && elapsed >= timeline[currentIndex].time) {
                            const event = timeline[currentIndex];
                            if (event.type === 'break') { STATE.activePins = []; STATE.activeCenterBrolls = []; }
                            else {
                                if (event.item && event.item.bgChange) {
                                    if (event.item.bgChange === 'reset') STATE.currentDynamicBg = null;
                                    else STATE.currentDynamicBg = event.item.bgChange;
                                }
                                if (event.item.isPinned && event.item.imgKey && !STATE.activePins.includes(event.item.imgKey)) STATE.activePins.push(event.item.imgKey);
                                if (event.item.isCenterBroll && event.item.imgKey && !STATE.activeCenterBrolls.find(b => b.key === event.item.imgKey)) STATE.activeCenterBrolls.push({ key: event.item.imgKey, spawn: performance.now() });
                            }
                            currentIndex++;
                        }
                    }

                    if (currentIndex < timeline.length || STATE.appMode === 'pro') STATE.animTimer = requestAnimationFrame(syncLoop);
                    else if (STATE.appMode === 'classic') finishPlayback();
                }
                STATE.animTimer = requestAnimationFrame(syncLoop);
            };

            let fallbackTimeout = setTimeout(startFallback, 500);

            u.onboundary = (e) => {
                boundaryFired = true; clearTimeout(fallbackTimeout);
                if (e.name === 'word') {
                    STATE.playbackProgress = (STATE.wordIndex / STATE.layout.length) * 100;

                    if (STATE.layout[STATE.wordIndex]?.isBreak) { STATE.objects = []; STATE.activePins = []; STATE.activeCenterBrolls = []; STATE.wordIndex++; }
                    while (STATE.layout[STATE.wordIndex]?.isBreak) { STATE.objects = []; STATE.activePins = []; STATE.activeCenterBrolls = []; STATE.wordIndex++; }

                    let w1 = STATE.layout[STATE.wordIndex];
                    if (w1?.isSilent && !w1?.isBreak) {
                        if (w1.bgChange) { if (w1.bgChange === 'reset') STATE.currentDynamicBg = null; else STATE.currentDynamicBg = w1.bgChange; }
                        spawnItem(w1);
                        if (w1.isCenterBroll && w1.imgKey) STATE.activeCenterBrolls.push({ key: w1.imgKey, spawn: performance.now() });
                        STATE.wordIndex++;
                    }

                    let w2 = STATE.layout[STATE.wordIndex];
                    if (w2 && !w2.isBreak) {
                        if (w2.bgChange) { if (w2.bgChange === 'reset') STATE.currentDynamicBg = null; else STATE.currentDynamicBg = w2.bgChange; }
                        spawnItem(w2);
                        if (w2.isCenterBroll && w2.imgKey) STATE.activeCenterBrolls.push({ key: w2.imgKey, spawn: performance.now() });
                        STATE.wordIndex++;
                    }

                    let w3 = STATE.layout[STATE.wordIndex];
                    if (w3?.isSilent && !w3?.isBreak) {
                        if (w3.bgChange) { if (w3.bgChange === 'reset') STATE.currentDynamicBg = null; else STATE.currentDynamicBg = w3.bgChange; }
                        spawnItem(w3);
                        if (w3.isCenterBroll && w3.imgKey) STATE.activeCenterBrolls.push({ key: w3.imgKey, spawn: performance.now() });
                        STATE.wordIndex++;
                    }
                }
            };

            u.onerror = (e) => { console.warn("TTS Error, running fallback", e); clearTimeout(fallbackTimeout); startFallback(); };
            u.onstart = () => { };
            u.onend = () => { if (!boundaryFired && !STATE.isFallbackPlaying) { clearTimeout(fallbackTimeout); startFallback(); } else if (boundaryFired) { finishPlayback(); } };
            window.speechSynthesis.speak(u);
        }

        function stopPreview() {
            window.speechSynthesis.cancel();
            if (STATE.currentAudio) { STATE.currentAudio.pause(); STATE.currentAudio = null; }
            if (STATE.animTimer) { clearInterval(STATE.animTimer); cancelAnimationFrame(STATE.animTimer); }

            // Clean up and Pause all dynamic videos to free memory
            const activeMedia = new Set();
            document.querySelectorAll('video[id^="dyn_vid_"]').forEach(v => {
                v.pause();
                v.currentTime = 0;
            });

            STATE.isFallbackPlaying = false;
            STATE.isFinishing = false;
            STATE.playbackProgress = 0;
            STATE.globalZoom = 0;
            STATE.activePins = [];
            STATE.activeCenterBrolls = [];
            STATE.currentDynamicBg = null; // Reset background to base
            resetUI(); STATE.isPlaying = false;
        }

        function resetUI() {
            document.getElementById('playBtn').innerHTML = '<i data-lucide="play" class="w-3 h-3"></i> PREVIEW';
            document.body.style.cursor = 'default'; lucide.createIcons();
            ['sfxPop', 'sfxWhoosh', 'sfxClick'].forEach(id => { const a = document.getElementById(id); if (a) { a.pause(); a.currentTime = 0; } });
        }

        function spawnItem(data) {
            if (data.isGap && !data.isCenterBroll) return;

            if (data.isPinned && data.imgKey && !STATE.activePins.includes(data.imgKey)) {
                STATE.activePins.push(data.imgKey);
                return;
            }

            if (!data.isCenterBroll && (!data.isSilent || data.imgKey || data.annotation)) {
                STATE.objects.push(new VisualItem(data));
            }

            if (data.isHighlight || data.isHuge) {
                for (let i = 0; i < 20; i++) {
                    STATE.particles.push(new Particle(data.x + data.width / 2, data.y, STATE.colors.high));
                }
            }

            const effAnim = data.customAnim || STATE.animation;
            if (effAnim === 'zoom' || STATE.proAnimation === 'bounce') STATE.screenShake = 12;
            if (effAnim === 'drop' || data.isCenterBroll) STATE.screenShake = 8;

            if (STATE.sfxEnabled) {
                if (data.imgKey || data.bgChange) playSound('whoosh');
                else if (data.isHighlight || data.isHuge) playSound('pop');
                else if (data.cleanText) playSound('click');
            }
        }

        function playSound(type) {
            const id = type === 'pop' ? 'sfxPop' : (type === 'whoosh' ? 'sfxWhoosh' : 'sfxClick');
            const audio = document.getElementById(id);
            if (audio) { audio.currentTime = 0; audio.volume = type === 'click' ? 0.3 : 0.8; audio.play().catch(e => { }); }
        }

        // --- CUSTOM FORMAT UI ---
        function customFormat() {
            const input = prompt("Enter aspect ratio (Width:Height)\nExamples: 16:9, 9:16, 1:1, 4:5", STATE.format.raw || "16:9");
            if (!input) return;
            const parts = input.split(':');
            if (parts.length === 2 && !isNaN(parts[0]) && !isNaN(parts[1])) {
                let rw = parseFloat(parts[0]);
                let rh = parseFloat(parts[1]);
                if (rw <= 0 || rh <= 0) return alert("Invalid ratio");

                let maxDim = 640;
                let w, h;
                if (rw > rh) { w = maxDim; h = (rh / rw) * maxDim; }
                else { h = maxDim; w = (rw / rh) * maxDim; }

                let fontSize = Math.max(20, Math.floor(w / 9));

                STATE.format = { w: w, h: h, pad: 30, fontSize: fontSize, raw: input };

                ['fmt916', 'fmt43', 'fmt11', 'fmtCustom'].forEach(id => document.getElementById(id).classList.remove('active-format'));
                document.getElementById('fmtCustom').classList.add('active-format');
                document.getElementById('fmtCustom').innerText = `‚öôÔ∏è ${input}`;

                resizeCanvas();
            } else {
                alert("Please enter a valid format like 16:9");
            }
        }

        // --- PRO ANIMATION EASING MATH ---
        const easeOutExpo = x => x === 1 ? 1 : 1 - Math.pow(2, -10 * x);
        const easeOutBack = x => { const c1 = 1.70158; const c3 = c1 + 1; return 1 + c3 * Math.pow(x - 1, 3) + c1 * Math.pow(x - 1, 2); };
        const easeOutElastic = x => x === 0 ? 0 : x === 1 ? 1 : Math.pow(2, -10 * x) * Math.sin((x * 10 - 0.75) * ((2 * Math.PI) / 3)) + 1;
        const easeOutBounce = x => {
            const n1 = 7.5625; const d1 = 2.75;
            if (x < 1 / d1) { return n1 * x * x; }
            else if (x < 2 / d1) { return n1 * (x -= 1.5 / d1) * x + 0.75; }
            else if (x < 2.5 / d1) { return n1 * (x -= 2.25 / d1) * x + 0.9375; }
            else { return n1 * (x -= 2.625 / d1) * x + 0.984375; }
        };

        // --- VISUAL ITEM (CLASSIC MODE) ---
        class VisualItem {
            constructor(data) {
                this.data = data;
                this.font = document.getElementById('fontSelect').value;
                this.animType = data.customAnim || (STATE.animation === 'mix' ? ['elastic', 'slide', 'glitch', 'cinema', 'spin', 'zoom', 'drop', 'blur', 'shake', 'flip', 'wave', 'kinetic', 'pop'][Math.floor(Math.random() * 13)] : STATE.animation);
                this.time = 0;
                this.scale = 0; this.opacity = 0; this.offsetY = 0; this.offsetX = 0; this.skewX = 0;
                this.rotation = (Math.random() - 0.5) * 0.05; this.blur = 0; this.glitchOffset = 0;
                this.pathProgress = 0;
            }
            update() {
                this.time += 0.04; if (this.time > 1) this.time = 1;

                let tExpo = easeOutExpo(this.time);
                let tBack = easeOutBack(this.time);
                let tElastic = easeOutElastic(this.time);

                switch (this.animType) {
                    case 'elastic': this.scale = tElastic; this.opacity = Math.min(this.time * 5, 1); break;
                    case 'kinetic': this.scale = 1; this.offsetX = (1 - tExpo) * -150; this.skewX = (1 - tExpo) * 0.5; this.opacity = tExpo; this.blur = (1 - tExpo) * 10; break;
                    case 'pop': this.scale = tBack; this.opacity = Math.min(this.time * 5, 1); break;
                    case 'zoom': this.scale = 3 - (2 * tExpo); this.opacity = tExpo; break;
                    case 'drop': this.scale = 1; this.offsetY = (1 - tBack) * -100; this.opacity = tExpo; break;
                    case 'slide': this.scale = 1; this.offsetY = (1 - tExpo) * 40; this.opacity = tExpo; break;
                    case 'glitch': this.scale = 1; this.opacity = 1; if (this.time < 0.3) this.glitchOffset = (Math.random() - 0.5) * 10; else this.glitchOffset = 0; break;
                    case 'cinema': this.scale = 1.2 - (this.time * 0.2); this.opacity = this.time; break;
                    case 'spin': this.scale = tBack; this.opacity = this.time; this.rotation = (1 - tExpo) * Math.PI; break;
                    case 'blur': this.scale = 1; this.opacity = this.time; this.blur = (1 - tExpo) * 10; break;
                    case 'shake': this.scale = tExpo; this.opacity = 1; if (this.time < 0.8) this.offsetY = (Math.random() - 0.5) * 20 * (1 - this.time); else this.offsetY = 0; break;
                    case 'flip': this.opacity = 1; this.scale = tBack; break;
                    case 'wave': this.scale = 1; this.opacity = this.time; this.offsetY = Math.sin(this.time * Math.PI * 2) * 10 * (1 - this.time); break;
                    default: this.scale = tElastic; this.opacity = tExpo; break;
                }
                if (this.data.annotation && this.pathProgress < 1) this.pathProgress += 0.05;
            }
            draw(ctx) {
                if (this.data.isGap && !this.data.isCenterBroll) return;

                // WIPE FX OVERRIDE
                if (this.data.isWipe && this.time < 0.5) {
                    ctx.save();
                    ctx.setTransform(1, 0, 0, 1, 0, 0);
                    ctx.fillStyle = STATE.colors.high;
                    ctx.globalAlpha = 1 - (this.time / 0.5);
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.restore();
                }

                ctx.save();
                let dx = this.data.x + this.data.width / 2 + this.glitchOffset + (this.offsetX || 0);
                let dy = this.data.y + this.offsetY;

                let currentScale = this.scale;
                if (this.data.isHuge) currentScale *= 1.4;
                else if (this.data.isHighlight) currentScale *= 1.15;

                ctx.translate(dx, dy);
                ctx.rotate(this.rotation);
                ctx.scale(currentScale, currentScale);
                if (this.skewX) ctx.transform(1, 0, this.skewX, 1, 0, 0);
                ctx.translate(-this.data.width / 2, 0);

                ctx.globalAlpha = this.opacity;
                if (this.blur > 0.1) ctx.filter = `blur(${this.blur}px)`;

                if (!this.data.isSilent && this.data.cleanText) {
                    ctx.font = `900 ${STATE.format.fontSize}px '${this.font}'`;
                    ctx.textBaseline = "middle";

                    if (this.data.isHighlight || this.data.isHuge) {
                        ctx.fillStyle = STATE.colors.high;
                        ctx.shadowColor = STATE.colors.high;
                        ctx.shadowBlur = 15;
                    } else {
                        ctx.fillStyle = STATE.colors.main;
                        ctx.shadowColor = "rgba(0,0,0,0.5)";
                        ctx.shadowBlur = 10;
                    }

                    ctx.shadowOffsetY = 4;

                    if (STATE.bgType !== 'color' || this.data.isHighlight || this.data.isHuge) {
                        ctx.strokeStyle = "black";
                        ctx.lineWidth = 4;
                        ctx.lineJoin = "round";
                        ctx.strokeText(this.data.cleanText, 0, 0);
                    }

                    ctx.fillText(this.data.cleanText, 0, 0);
                    ctx.shadowColor = "transparent";
                }
                if (this.data.imgKey && STATE.assets[this.data.imgKey] && !this.data.isPinned && !this.data.isCenterBroll) {
                    const img = getCachedImage(this.data.imgKey);
                    if (img && STATE.assetTypes[this.data.imgKey] !== 'video') {
                        const txtW = this.data.isSilent ? 0 : ctx.measureText(this.data.cleanText).width;
                        const size = this.data.imgSize;
                        ctx.drawImage(img, txtW + 5, -size / 2, size, size);
                    }
                }
                if (this.data.annotation) {
                    const w = ctx.measureText(this.data.cleanText).width; const h = STATE.format.fontSize;
                    ctx.strokeStyle = "#ff3b3b"; ctx.lineWidth = 4; ctx.lineCap = "round"; ctx.beginPath();
                    if (this.data.annotation === 'circle') ctx.ellipse(w / 2, 0, w / 1.5 * this.pathProgress, h * this.pathProgress, 0, 0, Math.PI * 2);
                    else if (this.data.annotation === 'arrow') {
                        const sx = -20; const sy = -40; const ex = 10; const ey = -10;
                        ctx.moveTo(sx, sy); ctx.lineTo(sx + (ex - sx) * this.pathProgress, sy + (ey - sy) * this.pathProgress);
                        if (this.pathProgress > 0.8) { ctx.lineTo(ex - 10, ey - 5); ctx.moveTo(ex, ey); ctx.lineTo(ex - 5, ey - 10); }
                    }
                    ctx.stroke();
                }
                ctx.restore();
            }
        }

        // --- NEW: PRO MOTION ENGINE RENDERING ---
        function drawProEngine(ctx) {
            const p = STATE.proPhrases.find(ph => STATE.proAudioTime >= ph.startTime && STATE.proAudioTime <= ph.endTime);
            if (!p) return;

            ctx.font = `900 ${STATE.format.fontSize}px '${document.getElementById('fontSelect').value}'`;
            ctx.textBaseline = "middle";

            let totalW = p.words.reduce((sum, w) => {
                if (w.item.isGap) return sum;
                return sum + ctx.measureText(w.item.cleanText + " ").width * (w.item.isHuge ? 1.4 : (w.item.isHighlight ? 1.15 : 1)) + (w.item.imgKey && STATE.assets[w.item.imgKey] && !w.item.isPinned && !w.item.isCenterBroll ? w.item.imgSize + 10 : 0)
            }, 0);

            let currentX = (STATE.format.w - totalW) / 2;
            let centerY = STATE.format.h / 2;

            if (p.words[0].item.alignX === 'left') currentX = 40;
            if (p.words[0].item.alignX === 'right') currentX = STATE.format.w - totalW - 40;
            if (p.words[0].item.alignY === 'top') centerY = STATE.format.h * 0.2;
            if (p.words[0].item.alignY === 'bottom') centerY = STATE.format.h * 0.8;

            p.words.forEach(w => {
                if (w.item.isGap && !w.item.isCenterBroll) return;

                const txt = w.item.cleanText + (w.item.isCenterBroll ? "" : " ");
                const rawWidth = ctx.measureText(txt).width;
                const sizeMult = w.item.isHuge ? 1.4 : (w.item.isHighlight ? 1.15 : 1);
                const wWidth = rawWidth * sizeMult;
                const imgSize = w.item.imgKey && STATE.assets[w.item.imgKey] && !w.item.isPinned && !w.item.isCenterBroll ? w.item.imgSize + 10 : 0;

                const isActive = STATE.proAudioTime >= w.time && STATE.proAudioTime < w.endTime;
                const isHighlight = w.item.isHighlight || w.item.isHuge;

                // Audio Sync Effects
                if (isActive && !w.hasTriggered) {
                    w.hasTriggered = true;
                    if (STATE.proAnimation === 'bounce') STATE.screenShake = 8;

                    if (isHighlight && !w.item.isCenterBroll) {
                        for (let i = 0; i < 20; i++) STATE.particles.push(new Particle(currentX + wWidth / 2, centerY, STATE.colors.high));
                        playSound('pop');
                    } else if (w.item.imgKey) {
                        playSound('whoosh');
                    } else if (w.item.cleanText) {
                        playSound('click');
                    }
                }

                // WIPE FX OVERRIDE
                if (w.item.isWipe && isActive) {
                    const duration = w.endTime - w.time;
                    const progress = Math.min((STATE.proAudioTime - w.time) / duration, 1);
                    if (progress < 0.3) {
                        ctx.save();
                        ctx.setTransform(1, 0, 0, 1, 0, 0);
                        ctx.fillStyle = STATE.colors.high;
                        ctx.globalAlpha = 1 - (progress / 0.3);
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                        ctx.restore();
                    }
                }

                if (w.item.isCenterBroll) return; // Drawn in master loop now

                ctx.save();

                let scaleX = sizeMult, scaleY = sizeMult, rot = 0, offY = 0, skewX = 0, blur = 0;
                let doLiquid = false, doRGB = false, doReveal = false;

                const effAnim = w.item.customAnim || STATE.proAnimation;

                if (isActive) {
                    const duration = w.endTime - w.time;
                    const progress = Math.min((STATE.proAudioTime - w.time) / duration, 1);

                    if (effAnim === 'hormozi') {
                        if (progress < 0.2) { scaleX *= 1.15; scaleY *= 1.15; rot = -0.04; }
                        else { scaleX *= 1.05; scaleY *= 1.05; }
                    } else if (effAnim === 'squash') {
                        if (progress < 0.2) { scaleX *= 0.8; scaleY *= 1.3; }
                        else if (progress < 0.4) { scaleX *= 1.2; scaleY *= 0.8; }
                        else { scaleX *= 1.1; scaleY *= 1.1; }
                    } else if (effAnim === 'rgb') {
                        scaleX *= 1.1; scaleY *= 1.1;
                        if (progress < 0.4) doRGB = true;
                    } else if (effAnim === 'liquid') {
                        scaleX *= 1.1; scaleY *= 1.1;
                        doLiquid = true;
                    } else if (effAnim === 'reveal') {
                        scaleX *= 1.1; scaleY *= 1.1;
                        const ease = easeOutExpo(progress);
                        offY = (1 - ease) * 60;
                        doReveal = true;
                    } else if (effAnim === 'bounce') {
                        const ease = easeOutBounce(Math.min(progress * 2.5, 1));
                        offY = (1 - ease) * -80;
                        scaleX *= 1.1; scaleY *= 1.1;
                    } else if (effAnim === 'kinetic') {
                        const ease = easeOutExpo(progress);
                        scaleX *= 1.1; scaleY *= 1.1;
                        currentX += (1 - ease) * -150;
                        skewX = (1 - ease) * 0.5;
                        blur = (1 - ease) * 10;
                    } else if (effAnim === 'elastic') {
                        const ease = easeOutElastic(progress);
                        scaleX *= ease; scaleY *= ease;
                    } else if (effAnim === 'zoom') {
                        const ease = easeOutExpo(progress);
                        scaleX *= (3 - (2 * ease)); scaleY *= (3 - (2 * ease));
                    } else {
                        scaleX *= 1.05; scaleY *= 1.05;
                    }

                    if (doReveal) {
                        ctx.beginPath();
                        ctx.rect(currentX - 10, centerY - STATE.format.fontSize + 10, wWidth + imgSize + 20, STATE.format.fontSize * 2);
                        ctx.clip();
                    }

                    ctx.translate(currentX + wWidth / 2 + imgSize / 2, centerY + offY);
                    ctx.scale(scaleX, scaleY);
                    ctx.rotate(rot);
                    if (skewX) ctx.transform(1, 0, skewX, 1, 0, 0);
                    if (blur) ctx.filter = `blur(${blur}px)`;

                    if (isHighlight && STATE.proAnimation === 'marker') {
                        ctx.fillStyle = STATE.colors.high;
                        ctx.beginPath();
                        ctx.roundRect(-rawWidth / 2 - 5, -STATE.format.fontSize / 2 - 8, rawWidth + 10, STATE.format.fontSize + 16, 6);
                        ctx.fill();
                        ctx.fillStyle = "#ffffff";
                    } else {
                        ctx.fillStyle = isHighlight ? STATE.colors.high : STATE.colors.main;
                    }

                    ctx.shadowColor = "rgba(0,0,0,0.5)"; ctx.shadowBlur = 10; ctx.shadowOffsetY = 4;
                    ctx.strokeStyle = "black"; ctx.lineWidth = 4; ctx.lineJoin = "round";

                    if (!w.item.isSilent) {
                        if (doLiquid) {
                            ctx.fillStyle = "rgba(255,255,255,0.2)";
                            ctx.fillText(w.item.cleanText, -rawWidth / 2 - imgSize / 2, 0);
                            ctx.save();
                            ctx.beginPath();
                            ctx.rect(-rawWidth / 2 - imgSize / 2 - 5, -STATE.format.fontSize, (rawWidth + imgSize + 10) * progress, STATE.format.fontSize * 2);
                            ctx.clip();
                            ctx.fillStyle = isHighlight ? STATE.colors.high : STATE.colors.main;
                            ctx.strokeText(w.item.cleanText, -rawWidth / 2 - imgSize / 2, 0);
                            ctx.fillText(w.item.cleanText, -rawWidth / 2 - imgSize / 2, 0);
                            ctx.restore();
                        } else if (doRGB) {
                            const glitchOffset = (0.4 - progress) * 25 * Math.random();
                            ctx.globalCompositeOperation = "screen";
                            ctx.fillStyle = "cyan"; ctx.fillText(w.item.cleanText, -rawWidth / 2 - imgSize / 2 - glitchOffset, 0);
                            ctx.fillStyle = "red"; ctx.fillText(w.item.cleanText, -rawWidth / 2 - imgSize / 2 + glitchOffset, 0);
                            ctx.globalCompositeOperation = "source-over";
                            ctx.fillStyle = "#ffffff"; ctx.fillText(w.item.cleanText, -rawWidth / 2 - imgSize / 2, 0);
                        } else {
                            ctx.strokeText(w.item.cleanText, -rawWidth / 2 - imgSize / 2, 0);
                            ctx.fillText(w.item.cleanText, -rawWidth / 2 - imgSize / 2, 0);
                        }
                    }

                } else {
                    ctx.translate(currentX + wWidth / 2 + imgSize / 2, centerY);
                    ctx.scale(sizeMult, sizeMult);
                    ctx.globalAlpha = 0.4;
                    ctx.fillStyle = STATE.colors.main;
                    ctx.strokeStyle = "black"; ctx.lineWidth = 4; ctx.lineJoin = "round";
                    if (!w.item.isSilent) {
                        ctx.strokeText(w.item.cleanText, -rawWidth / 2 - imgSize / 2, 0);
                        ctx.fillText(w.item.cleanText, -rawWidth / 2 - imgSize / 2, 0);
                    }
                }

                if (w.item.imgKey && STATE.assets[w.item.imgKey] && !w.item.isPinned && !w.item.isCenterBroll) {
                    const img = getCachedImage(w.item.imgKey);
                    if (img && STATE.assetTypes[w.item.imgKey] !== 'video') {
                        const txtW = w.item.isSilent ? 0 : rawWidth;
                        const size = w.item.imgSize;
                        ctx.globalAlpha = isActive ? 1.0 : 0.4;
                        ctx.drawImage(img, -rawWidth / 2 - imgSize / 2 + txtW + 5, -size / 2, size, size);
                    }
                }

                ctx.restore();
                currentX += wWidth + imgSize;
            });
        }

        // --- DRAWING ENGINE (MASTER LOOP) ---
        function drawCover(ctx, el, w, h) {
            const elW = el.videoWidth || el.naturalWidth || el.width;
            const elH = el.videoHeight || el.naturalHeight || el.height;
            if (!elW || !elH) return;
            const ratio = elW / elH;
            const cRatio = w / h;
            let dw, dh, dx, dy;
            if (ratio > cRatio) { dh = h; dw = h * ratio; dx = (w - dw) / 2; dy = 0; }
            else { dw = w; dh = w / ratio; dx = 0; dy = (h - dh) / 2; }
            try { ctx.drawImage(el, dx, dy, dw, dh); } catch (e) { }
        }

        function loop() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.save();

            // CAMERA PAN & SHAKE FX (PRO MODE)
            if (STATE.appMode === 'pro' && STATE.isPlaying) {
                STATE.globalZoom += 0.0004;
                const zoom = 1 + STATE.globalZoom;
                ctx.translate(canvas.width / 2, canvas.height / 2);
                ctx.scale(zoom, zoom);
                ctx.translate(-canvas.width / 2, -canvas.height / 2);
            }
            if (STATE.screenShake > 0.5) {
                ctx.translate((Math.random() - 0.5) * STATE.screenShake, (Math.random() - 0.5) * STATE.screenShake);
                STATE.screenShake *= 0.85;
            }

            // SMART VIDEO MEMORY MANAGER: Only play active dynamic videos
            const activeMedia = new Set();
            if (STATE.isPlaying) {
                if (STATE.currentDynamicBg) activeMedia.add(STATE.currentDynamicBg);
                STATE.activePins.forEach(k => activeMedia.add(k));
                STATE.activeCenterBrolls.forEach(b => activeMedia.add(b.key));
            }

            document.querySelectorAll('video[id^="dyn_vid_"]').forEach(v => {
                const k = v.id.replace('dyn_vid_', '');
                if (activeMedia.has(k)) {
                    if (v.paused) v.play().catch(e => { });
                } else {
                    if (!v.paused) v.pause();
                }
            });

            // DYNAMIC BACKGROUND HANDLING
            let currentBgType = STATE.baseBgType;
            let currentBgValue = STATE.baseBgValue;

            let dynVidEl = null;

            if (STATE.isPlaying && STATE.currentDynamicBg) {
                let bgKey = STATE.currentDynamicBg;
                if (bgKey.startsWith('#')) {
                    currentBgType = 'color';
                    currentBgValue = bgKey;
                } else if (STATE.assets[bgKey]) {
                    if (STATE.assetTypes && STATE.assetTypes[bgKey] === 'video') {
                        currentBgType = 'video';
                        dynVidEl = document.getElementById('dyn_vid_' + bgKey);
                    } else {
                        currentBgType = 'image';
                        currentBgValue = bgKey;
                    }
                }
            }

            if (currentBgType === 'color') {
                ctx.fillStyle = currentBgValue;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            } else if (currentBgType === 'image') {
                let imgToDraw = null;
                if (STATE.isPlaying && STATE.currentDynamicBg && !STATE.currentDynamicBg.startsWith('#')) {
                    imgToDraw = getCachedImage(currentBgValue);
                } else {
                    imgToDraw = document.getElementById('bgImgDisplay');
                }
                if (imgToDraw) drawCover(ctx, imgToDraw, canvas.width, canvas.height);
            } else if (currentBgType === 'video') {
                if (dynVidEl) {
                    if (dynVidEl.readyState >= 2) drawCover(ctx, dynVidEl, canvas.width, canvas.height);
                } else {
                    const vid = document.getElementById('bgVidDisplay');
                    if (vid && vid.readyState >= 2) drawCover(ctx, vid, canvas.width, canvas.height);
                }
            }

            // PINNED IMAGES (B-ROLL OVERLAYS)
            if (STATE.activePins && STATE.activePins.length > 0) {
                STATE.activePins.forEach((key, idx) => {
                    if (STATE.assetTypes[key] === 'video') {
                        let vidPin = document.getElementById('dyn_vid_' + key);
                        if (vidPin && vidPin.readyState >= 2) {
                            const w = canvas.width; const h = canvas.height; const size = w * 0.8;
                            ctx.shadowColor = "rgba(0,0,0,0.5)"; ctx.shadowBlur = 20;
                            ctx.drawImage(vidPin, w / 2 - size / 2, h / 2 - size / 2 - 60 + (idx * 15), size, size);
                            ctx.shadowColor = "transparent";
                        }
                    } else {
                        const img = getCachedImage(key);
                        if (img) {
                            const w = canvas.width; const h = canvas.height;
                            const size = w * 0.8;
                            ctx.shadowColor = "rgba(0,0,0,0.5)"; ctx.shadowBlur = 20;
                            ctx.drawImage(img, w / 2 - size / 2, h / 2 - size / 2 - 60 + (idx * 15), size, size);
                            ctx.shadowColor = "transparent";
                        }
                    }
                });
            }

            const tex = document.getElementById('textureSelect').value;
            if (tex === 'paper' && paperTexture.complete) {
                ctx.globalAlpha = 0.5;
                try { const pat = ctx.createPattern(paperTexture, 'repeat'); ctx.fillStyle = pat; ctx.fillRect(0, 0, canvas.width, canvas.height); } catch (e) { }
                ctx.globalAlpha = 1.0;
            } else if (tex === 'crt') {
                ctx.fillStyle = 'rgba(0,0,0,0.1)';
                for (let i = 0; i < canvas.height; i += 4) ctx.fillRect(0, i, canvas.width, 1);
            } else if (tex === 'noise') {
                ctx.drawImage(STATE.getNoiseCanvas(canvas.width, canvas.height), 0, 0);
            } else if (tex === 'grid') {
                ctx.fillStyle = 'rgba(255,255,255,0.07)';
                const spacing = 30;
                for (let x = 0; x < canvas.width; x += spacing) {
                    for (let y = 0; y < canvas.height; y += spacing) {
                        ctx.beginPath(); ctx.arc(x, y, 1.5, 0, Math.PI * 2); ctx.fill();
                    }
                }
            }

            // DRAW CENTER B-ROLLS (PERSISTENT UNTIL END OF SCENE)
            if (STATE.activeCenterBrolls && STATE.activeCenterBrolls.length > 0) {
                STATE.activeCenterBrolls.forEach(broll => {
                    let mediaToDraw = null;
                    if (STATE.assetTypes[broll.key] === 'video') {
                        let vidBroll = document.getElementById('dyn_vid_' + broll.key);
                        if (vidBroll && vidBroll.readyState >= 2) mediaToDraw = vidBroll;
                    } else {
                        mediaToDraw = getCachedImage(broll.key);
                    }

                    if (mediaToDraw) {
                        const size = STATE.format.w * 0.7;
                        const elapsedSec = (performance.now() - broll.spawn) / 1000;
                        const popScale = easeOutBack(Math.min(elapsedSec * 3, 1));

                        ctx.save();
                        ctx.setTransform(1, 0, 0, 1, 0, 0);
                        ctx.scale(SCALE, SCALE);
                        ctx.translate(STATE.format.w / 2, STATE.format.h / 2);
                        if (STATE.appMode === 'pro' && STATE.isPlaying) {
                            const zoom = 1 + STATE.globalZoom;
                            ctx.scale(zoom, zoom);
                        }
                        ctx.scale(popScale, popScale);
                        ctx.shadowColor = "rgba(0,0,0,0.6)"; ctx.shadowBlur = 40; ctx.shadowOffsetY = 15;
                        ctx.drawImage(mediaToDraw, -size / 2, -size / 2, size, size);
                        ctx.restore();
                    }
                });
            }

            // ROUTE TO CORRECT ENGINE
            ctx.scale(SCALE, SCALE);

            if (STATE.appMode === 'classic') {
                STATE.objects.forEach(o => { o.update(); o.draw(ctx); });
            } else {
                drawProEngine(ctx);
            }

            STATE.particles.forEach((p, i) => { p.update(); p.draw(ctx); if (p.life <= 0) STATE.particles.splice(i, 1); });

            ctx.restore();
            requestAnimationFrame(loop);
        }

        function resizeCanvas() {
            canvas.width = STATE.format.w * SCALE; canvas.height = STATE.format.h * SCALE;
            const container = document.getElementById('canvasContainer');
            container.style.width = `${STATE.format.w}px`; container.style.height = `${STATE.format.h}px`;

            const wrapper = container.parentElement;
            if (wrapper) {
                const availableW = wrapper.clientWidth - 32; const availableH = wrapper.clientHeight - 32;
                const scale = Math.min(availableW / STATE.format.w, availableH / STATE.format.h, 1);
                container.style.transform = `scale(${scale})`;
            }
        }

        function setFormat(fmt) {
            const m = { '9:16': { w: 360, h: 640, pad: 30, fontSize: 40, raw: '9:16' }, '4:3': { w: 640, h: 480, pad: 40, fontSize: 38, raw: '4:3' }, '1:1': { w: 500, h: 500, pad: 40, fontSize: 46, raw: '1:1' } };
            if (m[fmt]) {
                STATE.format = m[fmt];
                ['fmt916', 'fmt43', 'fmt11', 'fmtCustom'].forEach(id => document.getElementById(id).classList.remove('active-format'));
                document.getElementById('fmt' + fmt.replace(':', '')).classList.add('active-format');
                document.getElementById('fmtCustom').innerText = '‚öôÔ∏è Custom';
                resizeCanvas();
            }
        }

        function setBackground(t, v) {
            STATE.bgType = t; STATE.bgValue = v;
            STATE.baseBgType = t; STATE.baseBgValue = v; // Update baseline
            const i = document.getElementById('bgImgDisplay'), vid = document.getElementById('bgVidDisplay'), c = document.getElementById('bgColorDisplay');
            i.classList.add('hidden'); vid.classList.add('hidden'); c.classList.add('hidden'); vid.pause();
            if (t === 'image') { i.src = v; i.classList.remove('hidden'); } else if (t === 'video') { vid.src = v; vid.classList.remove('hidden'); vid.play(); } else { c.style.backgroundColor = v; c.classList.remove('hidden'); }
        }
        function handleBgUpload(i, t) { const f = i.files[0]; if (f) setBackground(t, URL.createObjectURL(f)); }

        function updateTexture() {
            const v = document.getElementById('textureSelect').value, o = document.getElementById('textureOverlay');
            o.className = 'absolute inset-0 pointer-events-none z-10 opacity-30 ';
            if (v === 'paper') o.style.backgroundImage = 'url("https://www.transparenttextures.com/patterns/cream-paper.png")';
            else if (v === 'crt') o.classList.add('scanlines'); else if (v === 'noise') o.classList.add('noise-overlay'); else o.style.backgroundImage = 'none';
        }
        function toggleSFX() { STATE.sfxEnabled = !STATE.sfxEnabled; document.getElementById('sfxBtn').className = STATE.sfxEnabled ? "bg-green-500/10 border border-green-500/30 text-green-400 rounded-lg p-2 text-xs font-bold flex items-center justify-center gap-2 transition" : "bg-red-500/10 border border-red-500/30 text-red-400 rounded-lg p-2 text-xs font-bold flex items-center justify-center gap-2 transition"; document.getElementById('sfxBtn').innerHTML = STATE.sfxEnabled ? '<i data-lucide="volume-2" class="w-3 h-3"></i> SFX: ON' : '<i data-lucide="volume-x" class="w-3 h-3"></i> SFX: OFF'; lucide.createIcons(); }
        function updateColor(t, v) { STATE.colors[t] = v; document.getElementById(t === 'main' ? 'mainColorPreview' : 'highColorPreview').style.backgroundColor = v; }

        async function handleAssetUpload(i) {
            const f = i.files[0], k = document.getElementById('assetName').value.trim().toLowerCase();
            if (f && k) {
                if (f.type.startsWith('video/')) {
                    STATE.assets[k] = URL.createObjectURL(f);
                    STATE.assetTypes[k] = 'video';
                    STATE.imageCache[k] = null;

                    // PRELOAD VIDEO ELEMENT
                    if (!document.getElementById('dyn_vid_' + k)) {
                        let v = document.createElement('video');
                        v.id = 'dyn_vid_' + k; v.src = STATE.assets[k];
                        v.muted = true; v.loop = true; v.playsInline = true;
                        v.style.display = 'none'; v.preload = 'auto';
                        document.body.appendChild(v);
                    }
                    renderAssets();
                } else {
                    const r = new FileReader();
                    r.onload = e => {
                        STATE.assets[k] = e.target.result;
                        STATE.assetTypes[k] = 'image';
                        STATE.imageCache[k] = null;
                        renderAssets();
                        saveAssets();
                    };
                    r.readAsDataURL(f);
                }
            }
        }
        function renderAssets() {
            const d = document.getElementById('assetList');
            d.innerHTML = '';
            Object.keys(STATE.assets).forEach(k => {
                const isVid = STATE.assetTypes[k] === 'video';
                const media = isVid ? `<video src="${STATE.assets[k]}" class="w-10 h-10 object-cover rounded bg-black"></video>` : `<img src="${STATE.assets[k]}" class="w-10 h-10 object-cover rounded bg-black">`;

                d.innerHTML += `
                <div class="bg-[#151517] border border-white/10 rounded-lg p-2 flex flex-col gap-2 w-full">
                    <div class="flex items-center justify-between">
                        <div class="flex items-center gap-3">
                            ${media}
                            <span class="text-xs font-bold truncate max-w-[150px]">${k}</span>
                        </div>
                        <button onclick="deleteAsset('${k}')" class="text-red-400 p-1 hover:text-red-300 transition"><i data-lucide="trash-2" class="w-4 h-4"></i></button>
                    </div>
                    <div class="flex gap-1.5 mt-1">
                        <button onclick="insertTag('[bg=${k}]')" class="flex-1 py-1.5 text-[9px] font-bold bg-indigo-900/50 text-indigo-300 rounded border border-indigo-700/50 hover:bg-indigo-600 hover:text-white transition">Set as BG</button>
                        <button onclick="insertTag('[=${k}]')" class="flex-1 py-1.5 text-[9px] font-bold bg-green-900/50 text-green-300 rounded border border-green-700/50 hover:bg-green-600 hover:text-white transition">Center B-Roll</button>
                        <button onclick="insertTag('[+${k}]')" class="flex-1 py-1.5 text-[9px] font-bold bg-blue-900/50 text-blue-300 rounded border border-blue-700/50 hover:bg-blue-600 hover:text-white transition">Side Pin</button>
                    </div>
                </div>`;
            });
            lucide.createIcons();
            if (STATE.editorMode === 'story') renderStoryboard();
        }
        window.deleteAsset = (k) => {
            delete STATE.assets[k]; delete STATE.imageCache[k]; delete STATE.assetTypes[k];
            const v = document.getElementById('dyn_vid_' + k);
            if (v) { v.pause(); v.removeAttribute('src'); v.load(); v.remove(); }
            renderAssets(); saveAssets();
        };
        function saveAssets() {
            try {
                // Only save images to localStorage to prevent quota exceeded errors
                let saveObj = {};
                Object.keys(STATE.assets).forEach(k => {
                    if (STATE.assetTypes[k] !== 'video') saveObj[k] = STATE.assets[k];
                });
                localStorage.setItem('vs_assets', JSON.stringify(saveObj));
            } catch (e) { }
        }
        function loadAssets() {
            try {
                STATE.assets = JSON.parse(localStorage.getItem('vs_assets') || '{}');
                Object.keys(STATE.assets).forEach(k => STATE.assetTypes[k] = 'image');
                renderAssets();
            } catch (e) { }
        }
        async function handleFontUpload(i) { const f = i.files[0]; if (f) { const r = new FileReader(); r.onload = e => { const n = f.name.split('.')[0]; new FontFace(n, `url(${e.target.result})`).load().then(x => { document.fonts.add(x); addFontOption(n); saveFont(n, e.target.result); }); }; r.readAsDataURL(f); } }
        function addFontOption(n) { const g = document.getElementById('customFontGroup'); if (![...g.options].some(o => o.value === n)) { const o = document.createElement('option'); o.text = n; o.value = n; g.appendChild(o); document.getElementById('fontSelect').value = n; } }
        function saveFont(n, d) { let s = JSON.parse(localStorage.getItem('vs_fonts') || '[]'); if (!s.some(x => x.name === n)) { s.push({ name: n, data: d }); localStorage.setItem('vs_fonts', JSON.stringify(s)); } }
        function loadSavedFonts() { try { JSON.parse(localStorage.getItem('vs_fonts') || '[]').forEach(f => { new FontFace(f.name, `url(${f.data})`).load().then(l => { document.fonts.add(l); addFontOption(f.name); }); }); } catch (e) { } }

        function loadVoices() {
            const s = document.getElementById('voiceSelect'); const currentSelection = s.value; s.innerHTML = '';
            window.speechSynthesis.getVoices().forEach(v => { s.innerHTML += `<option value="${v.name}">${v.name} (${v.lang})</option>`; });
            if (currentSelection && Array.from(s.options).some(o => o.value === currentSelection)) s.value = currentSelection;
        }

        // --- VISUAL EDITOR HELPERS ---
        function insertTag(tag) {
            if (STATE.editorMode === 'story') {
                if (STATE.storyScenes.length === 0) addStoryScene();
                const lastIdx = STATE.storyScenes.length - 1;

                if (tag.startsWith('[bg=')) {
                    const key = tag.substring(4, tag.length - 1);
                    updateStoryScene(lastIdx, 'bg', key);
                    renderStoryboard();
                } else if (tag.startsWith('[=')) {
                    const key = tag.substring(2, tag.length - 1);
                    updateStoryScene(lastIdx, 'broll', key);
                    renderStoryboard();
                } else {
                    const currentText = STATE.storyScenes[lastIdx].text;
                    updateStoryScene(lastIdx, 'text', currentText + (currentText ? " " : "") + tag);
                    renderStoryboard();
                }
            } else {
                const textarea = document.getElementById('scriptInput');
                const start = textarea.selectionStart;
                const end = textarea.selectionEnd;
                const text = textarea.value;
                const pad = (start > 0 && text[start - 1] !== ' ' && text[start - 1] !== '\n') ? ' ' : '';
                textarea.value = text.substring(0, start) + pad + tag + " " + text.substring(end);
                textarea.focus();
                const newCursor = start + pad.length + tag.length + 1;
                textarea.setSelectionRange(newCursor, newCursor);
            }
        }

        function wrapText(startTag, endTag) {
            const textarea = document.getElementById('scriptInput');
            const start = textarea.selectionStart;
            const end = textarea.selectionEnd;
            const text = textarea.value;

            if (start === end) {
                const placeholder = "text";
                textarea.value = text.substring(0, start) + startTag + placeholder + endTag + text.substring(end);
                textarea.focus();
                textarea.setSelectionRange(start + startTag.length, start + startTag.length + placeholder.length);
            } else {
                const selected = text.substring(start, end);
                textarea.value = text.substring(0, start) + startTag + selected + endTag + text.substring(end);
                textarea.focus();
                textarea.setSelectionRange(end + startTag.length + endTag.length, end + startTag.length + endTag.length);
            }
        }

        // --- DIRECT BACKGROUND EXPORT ---
        async function exportWithAudio() {
            if (STATE.isExporting) return;
            STATE.isExporting = true;

            let tracks = [];
            let canvasStream;
            // 30 FPS for standard video smoothness
            try { canvasStream = canvas.captureStream(30); }
            catch (e) { STATE.isExporting = false; return alert("Canvas recording not supported."); }
            tracks.push(canvasStream.getVideoTracks()[0]);

            let audioCtx = null;
            let desktopAudioStream = null;

            if (STATE.voiceMode === 'tts') {
                const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry/i.test(navigator.userAgent) || window.innerWidth < 768;
                if (!isMobile && navigator.mediaDevices && navigator.mediaDevices.getDisplayMedia) {
                    try {
                        desktopAudioStream = await navigator.mediaDevices.getDisplayMedia({ video: true, audio: true, preferCurrentTab: true });
                        if (desktopAudioStream.getAudioTracks().length > 0) { tracks.push(desktopAudioStream.getAudioTracks()[0]); }
                        else { alert("You didn't check 'Share Audio'. Video will be silent."); }
                    } catch (e) { console.warn("Screen share denied"); }
                } else {
                    alert("MOBILE NOTE:\nSystem AI voices cannot be recorded internally by mobile browsers (they block it for security).\n\nYour video will export smoothly, but it will be SILENT.\n\nTo get a video WITH SOUND on mobile, please switch to the '‚ú® Magic', 'Me', '11Labs', or 'Upload' tab.");
                }
            }

            if (STATE.isPlaying) stopPreview();

            const exportBtn = document.getElementById('exportVideoBtn');
            const originalBtnHtml = exportBtn.innerHTML;
            const originalBtnClass = exportBtn.className;
            exportBtn.innerHTML = '<div class="w-4 h-4 border-2 border-white border-t-transparent rounded-full animate-spin"></div> <span id="exportProgressText">RECORDING... 0%</span>';
            exportBtn.className = "w-full bg-purple-800 text-white font-bold py-3 rounded-xl text-xs flex items-center justify-center gap-2 cursor-not-allowed";

            let progInt = setInterval(() => {
                const pText = document.getElementById('exportProgressText');
                if (pText) {
                    if (STATE.isFinishing) pText.innerText = "FINALIZING (2s)...";
                    else pText.innerText = `RECORDING... ${Math.min(99, Math.floor(STATE.playbackProgress || 0))}%`;
                }
            }, 200);

            await startPreview();

            setTimeout(() => {
                if (STATE.currentAudio && STATE.voiceMode !== 'tts') {
                    try {
                        let audioStream;
                        if (STATE.currentAudio.captureStream) {
                            audioStream = STATE.currentAudio.captureStream();
                        } else if (STATE.currentAudio.mozCaptureStream) {
                            audioStream = STATE.currentAudio.mozCaptureStream();
                        }

                        if (audioStream && audioStream.getAudioTracks().length > 0) {
                            tracks.push(audioStream.getAudioTracks()[0]);
                        } else {
                            const AudioContext = window.AudioContext || window.webkitAudioContext;
                            audioCtx = new AudioContext();
                            const dest = audioCtx.createMediaStreamDestination();
                            STATE.currentAudio.crossOrigin = "anonymous";
                            const source = audioCtx.createMediaElementSource(STATE.currentAudio);
                            source.connect(dest);
                            source.connect(audioCtx.destination);
                            if (dest.stream.getAudioTracks().length > 0) tracks.push(dest.stream.getAudioTracks()[0]);
                        }
                    } catch (e) { console.warn("Audio capture failed", e); }
                }

                const combinedStream = new MediaStream(tracks);

                const combinedStream = new MediaStream(tracks);

                // HIGH QUALITY EXPORT SETTINGS
                // 12 Mbps bitrate for crisp 1080p video
                // VP9 codec for best compression/quality ratio
                const options = {
                    mimeType: 'video/webm; codecs=vp9',
                    videoBitsPerSecond: 12000000 // 12 Mbps 
                };

                // Fallback codecs if VP9 not supported
                if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                    options.mimeType = 'video/webm; codecs=vp8';
                }
                if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                    options.mimeType = 'video/webm';
                    delete options.videoBitsPerSecond; // Use default if codec specific not supported
                }

                let recorder;
                try { recorder = new MediaRecorder(combinedStream, options); }
                catch (e) {
                    STATE.isExporting = false;
                    clearInterval(progInt);
                    exportBtn.innerHTML = originalBtnHtml;
                    exportBtn.className = originalBtnClass;
                    return alert("MediaRecorder failed.");
                }

                const chunks = [];
                recorder.ondataavailable = e => { if (e.data.size > 0) chunks.push(e.data); };

                recorder.onstop = () => {
                    const blob = new Blob(chunks, { type: recorder.mimeType || 'video/mp4' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.style.display = 'none';
                    a.href = url;
                    a.download = `ViralStudio_Export.${(recorder.mimeType && recorder.mimeType.includes('webm')) ? 'webm' : 'mp4'}`;
                    document.body.appendChild(a);
                    a.click();
                    setTimeout(() => { document.body.removeChild(a); URL.revokeObjectURL(url); }, 100);

                    if (desktopAudioStream) desktopAudioStream.getTracks().forEach(t => t.stop());
                    if (audioCtx) audioCtx.close();

                    clearInterval(progInt);
                    exportBtn.innerHTML = originalBtnHtml;
                    exportBtn.className = originalBtnClass;
                    STATE.isExporting = false;
                };

                recorder.start();

                const oldStop = stopPreview;
                stopPreview = () => {
                    if (recorder.state === 'recording') recorder.stop();
                    oldStop(); stopPreview = oldStop;
                };

            }, 500);
        }

        init();
        window.addEventListener('resize', resizeCanvas);
    </script>
</body>

</html>
